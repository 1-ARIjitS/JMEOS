package jmeos.functions.builder;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static jmeos.functions.builder.BuilderLibrary.*;

/**
 * Class used to extract the functions from the MEOS library.
 * Run with ./script folder or as follows:
 * <ul>
 *     <li>cd src/main/java/jmeos/functions/builder</li>
 *     <li>javac ./FunctionsBuilder.java</li>
 *     <li>java ./FunctionsBuilder.java</li>
 * </ul>
 * <p>
 * TODO: Ajouter un process d'ajout de code dans le body des fonctions. do function(function name, Runnable
 *
 * @author Killian Monnier
 * @since 27/06/2023
 */
public class FunctionsBuilder {
	private static final String FILE_PATH = "";
	private static final String C_FUNCTIONS_PATH = FILE_PATH + "tmp/meos_functions.h"; // File generated by the FunctionsExtractor class
	private static final String C_TYPES_PATH = FILE_PATH + "tmp/meos_types.h"; // File generated by the FunctionsExtractor class
	private static final HashMap<String, String> TYPES = typesBuild(); // Creation of the C type dictionary and its equivalent in Java
	private static final String FUNCTIONS_CLASS_PATH = FILE_PATH + "../functions.java"; // Generated functions class
	private static final ArrayList<String> unSupportedTypes = new ArrayList<>(); // List of unsupported types
	
	/**
	 * Builds the type modification array.
	 * <p>
	 * Key: old type in C or modified
	 * <p>
	 * Value: new type in Java
	 *
	 * @return type dictionary
	 */
	private static HashMap<String, String> typesBuild() {
		HashMap<String, String> typeChange = new HashMap<>();
		typeChange.put("\\*", "Pointer");
		typeChange.put("\\*char", "String");
		typeChange.put("bool", "boolean");
		typeChange.put("float", "float");
		typeChange.put("double", "double");
		typeChange.put("void", "void");
		typeChange.put("int", "int");
		typeChange.put("short", "short");
		typeChange.put("long", "long");
		typeChange.put("int8", "byte");
		typeChange.put("int16", "short");
		typeChange.put("int32", "int");
		typeChange.put("int64", "long");
		typeChange.put("int8_t", "byte");
		typeChange.put("int16_t", "short");
		typeChange.put("int32_t", "int");
		typeChange.put("int64_t", "long");
		typeChange.put("uint8", "byte");
		typeChange.put("uint16", "short");
		typeChange.put("uint32", "int");
		typeChange.put("uint64", "long");
		typeChange.put("uint8_t", "byte");
		typeChange.put("uint16_t", "short");
		typeChange.put("uint32_t", "int");
		typeChange.put("uint64_t", "long");
		typeChange.put("uintptr_t", "long");
		typeChange.put("size_t", "long");
		typeChange.put("interpType", "int"); // enum in C
		
		/* Added typedefs extracted from C file */
		readFileLines(C_TYPES_PATH, line -> {
			Pattern pattern = Pattern.compile("^typedef\\s(\\w+)\\s(\\w+);");
			Matcher matcher = pattern.matcher(line);
			if (matcher.find()) {
				String rawType = matcher.group(1);
				String typeDef = matcher.group(2);
				
				if (typeChange.containsKey(rawType))
					rawType = typeChange.get(rawType); // Changing Types with Java Compatible Types
				
				typeChange.put(typeDef, rawType);
			} else {
				System.out.println("Cannot extract type for row: " + line);
			}
		});
		
		return typeChange;
	}
	
	/**
	 * Main script execution function.
	 *
	 * @param args arguments
	 */
	public static void main(String[] args) {
		StringBuilder functionsBuilder = generateFunctions();
		StringBuilder interfaceBuilder = generateInterface(functionsBuilder);
		StringBuilder classBuilder = generateClass(functionsBuilder, interfaceBuilder);
		writeFileFromBuilder(classBuilder, FUNCTIONS_CLASS_PATH);
	}
	
	/**
	 * Used to generate the class of functions.
	 *
	 * @param functionsBuilder builder of functions
	 * @param interfaceBuilder interface builder
	 * @return the class builder
	 */
	private static StringBuilder generateClass(StringBuilder functionsBuilder, StringBuilder interfaceBuilder) {
		StringBuilder builder = new StringBuilder();
		
		/* Get the package name */
		Package pkg = FunctionsBuilder.class.getPackage();
		String packageName = pkg.getName();
		String basePackage = packageName.substring(0, packageName.lastIndexOf('.'));
		String definePackage = "package " + basePackage + ";\n";
		
		String imports = """
				import jnr.ffi.LibraryLoader;
				import jnr.ffi.Pointer;
				""";
		String className = "public class functions {";
		builder.append(definePackage).append("\n").append(imports).append("\n").append(className).append("\n");
		
		/* Added interface */
		appendStringBuilders(interfaceBuilder, builder, "\t", "\n\n");
		
		/* Addition of functions */
		StringBuilder functionBodyBuilder = new StringBuilder();
		readBuilderLines(functionsBuilder, line -> {
			if (!line.isBlank()) {
				String functionSignature = "public static " + removeSemicolon(line) + " {\n";
				String functionBody = "\t" + "return MeosLibrary.meos." + extractFunctionName(line) + "(" + getListWithoutBrackets(extractParamNames(line)) + ");\n}\n\n";
				
				if (getFunctionTypes(line).get(0).equals("void"))
					functionBody = "\t" + "MeosLibrary.meos." + extractFunctionName(line) + "(" + getListWithoutBrackets(extractParamNames(line)) + ");\n}\n\n"; // When the function returns nothing
				
				functionBodyBuilder.append("@SuppressWarnings(\"unused\")\n") // Allows us to suppress unnecessary warnings
						.append(functionSignature).append(functionBody);
			}
		});
		appendStringBuilders(functionBodyBuilder, builder, "\t", "\n");
		builder.append("}");
		return builder;
	}
	
	/**
	 * Generation of the interface.
	 *
	 * @param functionsBuilder builder of functions
	 * @return the interface builder
	 */
	private static StringBuilder generateInterface(StringBuilder functionsBuilder) {
		StringBuilder builder = new StringBuilder();
		
		builder.append("""
				public interface MeosLibrary {
					functions.MeosLibrary INSTANCE = LibraryLoader.create(functions.MeosLibrary.class).load("meos");
					functions.MeosLibrary meos = functions.MeosLibrary.INSTANCE;
				""");
		appendStringBuilders(functionsBuilder, builder, "\t", "\n");
		builder.append("}");
		return builder;
	}
	
	/**
	 * Generation of functions with their modified types.
	 *
	 * @return the function builder
	 */
	private static StringBuilder generateFunctions() {
		StringBuilder builder = new StringBuilder();
		
		readFileLines(FunctionsBuilder.C_FUNCTIONS_PATH, line -> {
			String processedLine = changeFunctionType(line) + "\n";
			builder.append(processedLine);
		});
		System.out.println("Unsupported types: " + unSupportedTypes);
		return builder;
	}
	
	//	public static void addFunctionBodyCode("functionName", args -> {
	//
	//		// ton code dedans
	//		// args correspond à un array des paramètres de la fonction
	//	});
	
	/**
	 * Processes the rows to generate the functions.
	 *
	 * @param line the line corresponding to a function
	 * @return the processed line
	 */
	private static String changeFunctionType(String line) {
		if (!line.isBlank()) {
			// Remove keywords that are not of interest to us
			line = line.replaceAll("extern ", "");
			line = line.replaceAll("const ", "");
			line = line.replaceAll("static inline ", "");
			
			// Changing types with *
			line = line.replaceAll("char\\s\\*", "*char ");
			line = line.replaceAll("\\w+\\s\\*\\*", "*[] ");
			line = line.replaceAll("\\w+\\s\\*(?!\\*)", "* ");
			
			// Changing special types or names
			line = line.replaceAll("\\(void\\)", "()"); // Remove the void parameter (for the function meos_finish(void))
			line = line.replaceAll("synchronized", "synchronize"); // Change the keyword used by Java (for the function temporal_simplify(const Temporal *temp, double eps_dist, bool synchronized))
			
			// Replaces types from type dictionary
			for (Map.Entry<String, String> entry : TYPES.entrySet()) {
				String oldType = entry.getKey();
				String newType = entry.getValue();
				line = line.replaceAll("(^|\\(|\\s)" + oldType + "(\\s|\\[\\])", "$1" + newType + "$2");
			}
			
			List<String> typesNotSupported = getFunctionTypes(line).stream().filter(type -> !TYPES.containsValue(type)).toList(); // Retrieving unsupported types for the line
			unSupportedTypes.addAll(typesNotSupported.stream().filter(type -> !unSupportedTypes.contains(type)).toList()); // Fetch unsupported types that are not yet in the global list
		}
		
		return line;
	}
}