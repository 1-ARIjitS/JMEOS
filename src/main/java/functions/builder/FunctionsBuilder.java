package functions.builder;

import utils.BuilderLibrary;
import utils.Pair;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Class used to extract the functions from the MEOS library.
 * Run with ./script folder
 *
 * @author Killian Monnier
 * @since 27/06/2023
 */
public class FunctionsBuilder {
	private static final String BUILDER_PATH = "src/main/java/functions/builder/";
	private static final String C_FUNCTIONS_PATH = BUILDER_PATH + "tmp/meos_functions.h"; // File generated by the FunctionsExtractor class
	private static final String C_TYPES_PATH = BUILDER_PATH + "tmp/meos_types.h"; // File generated by the FunctionsExtractor class
	private static final HashMap<String, String> TYPES_CONVERSION = typesBuild(); // Creation of the C type dictionary and its equivalent in Java
	private static final String FUNCTIONS_CLASS_PATH = BUILDER_PATH + "../functions_new.java"; // Generated functions class
	private static final ArrayList<String> UNSUPPORTED_TYPES = new ArrayList<>(); // List of unsupported types
	private static final ArrayList<String> CONVERSION_PROCESS_TYPES = new ArrayList<>(Arrays.asList("LocalDateTime", "ZonedDateTime")); // List of types to perform a conversion
	
	/**
	 * Builds the type modification array.
	 * <p>
	 * Key: old type in C or modified
	 * <p>
	 * Value: new type in Java
	 *
	 * @return type dictionary
	 */
	private static HashMap<String, String> typesBuild() {
		HashMap<String, String> typeChange = new HashMap<>();
		typeChange.put("\\*", "Pointer");
		typeChange.put("\\*char", "String");
		typeChange.put("Pointer\\[\\]", "Pointer"); // Keep this line, otherwise operand error in JNR-FFI
		typeChange.put("bool", "boolean");
		typeChange.put("float", "float");
		typeChange.put("double", "double");
		typeChange.put("void", "void");
		typeChange.put("int", "int");
		typeChange.put("short", "short");
		typeChange.put("long", "long");
		typeChange.put("int8", "byte");
		typeChange.put("int16", "short");
		typeChange.put("int32", "int");
		typeChange.put("int64", "long");
		typeChange.put("int8_t", "byte");
		typeChange.put("int16_t", "short");
		typeChange.put("int32_t", "int");
		typeChange.put("int64_t", "long");
		typeChange.put("uint8", "byte");
		typeChange.put("uint16", "short");
		typeChange.put("uint32", "int");
		typeChange.put("uint64", "long");
		typeChange.put("uint8_t", "byte");
		typeChange.put("uint16_t", "short");
		typeChange.put("uint32_t", "int");
		typeChange.put("uint64_t", "long");
		typeChange.put("uintptr_t", "long");
		typeChange.put("size_t", "long");
		typeChange.put("interpType", "int"); // enum in C
		typeChange.put("Timestamp", "LocalDateTime");
		typeChange.put("TimestampTz", "ZonedDateTime"); //TODO mettre Ã§a dans un autre dict, faire la modif pour function mais pas dans l'interface, faire seulement la modife des types Java
		
		/* Added typedefs extracted from C file */
		BuilderLibrary.readFileLines(C_TYPES_PATH, line -> {
			Pattern pattern = Pattern.compile("^typedef\\s(\\w+)\\s(\\w+);");
			Matcher matcher = pattern.matcher(line);
			if (matcher.find()) {
				String rawType = matcher.group(1);
				String typeDef = matcher.group(2);
				
				/* Changing Types with Java Compatible Types if not in the typeChangeList */
				if (typeChange.containsKey(rawType) && !typeChange.containsKey(typeDef)) {
					rawType = typeChange.get(rawType);
					typeChange.put(typeDef, rawType);
				}
			} else {
				System.out.println("Cannot extract type for row: " + line);
			}
		});
		
		return typeChange;
	}
	
	/**
	 * Main script execution function.
	 *
	 * @param args arguments
	 */
	public static void main(String[] args) {
		// Retrieve the value of the JMEOS_PATH environment variable
		String jmeosHome = System.getenv("JMEOS_HOME");
		
		// Check if environment variable exists
		if (jmeosHome != null) {
			System.out.println("JMEOS_HOME: " + jmeosHome);
			
			// Set the current working directory
			System.setProperty("user.dir", jmeosHome);
			
			// Check if the current working directory has been updated
			String currentWorkingDir = System.getProperty("user.dir");
			System.out.println("Current working directory: " + currentWorkingDir);
			
			StringBuilder functionsBuilder = generateFunctions();
			StringBuilder interfaceBuilder = generateInterface(functionsBuilder);
			StringBuilder classBuilder = generateClass(functionsBuilder, interfaceBuilder);
			BuilderLibrary.writeFileFromBuilder(classBuilder, FUNCTIONS_CLASS_PATH);
		} else {
			System.err.println("The JMEOS_HOME environment variable is not set.\nCancellation of build.");
		}
	}
	
	/**
	 * Used to generate the class of functions.
	 *
	 * @param functionsBuilder builder of functions
	 * @param interfaceBuilder interface builder
	 * @return the class builder
	 */
	private static StringBuilder generateClass(StringBuilder functionsBuilder, StringBuilder interfaceBuilder) {
		StringBuilder builder = new StringBuilder();
		
		/* Get the package name */
		Package pkg = FunctionsBuilder.class.getPackage();
		String packageName = pkg.getName();
		String basePackage = packageName.substring(0, packageName.lastIndexOf('.'));
		String definePackage = "package " + basePackage + ";\n";
		
		String imports = """
				import jnr.ffi.LibraryLoader;
				import jnr.ffi.Pointer;
				
				import java.time.LocalDateTime;
				import java.time.ZonedDateTime;
				""";
		String className = "public class functions {";
		builder.append(definePackage).append("\n").append(imports).append("\n").append(className).append("\n");
		
		/* Added interface */
		BuilderLibrary.appendStringBuilders(interfaceBuilder, builder, "\t", "\n\n");
		
		/* Addition of functions */
		StringBuilder functionBodyBuilder = new StringBuilder();
		BuilderLibrary.readBuilderLines(functionsBuilder, line -> {
			if (!line.isBlank()) {
				String functionSignature = "public static " + BuilderLibrary.removeSemicolon(line) + " {\n";
				List<String> functionTypeConversion = getTypeConversionProcess(line);
				
				String functionCall = "";
				if (!getFunctionTypes(line).get(0).equals("void")) // When return
					functionCall += "return ";
				functionCall += "MeosLibrary.meos." + BuilderLibrary.extractFunctionName(line) + "(" + BuilderLibrary.getListWithoutBrackets(BuilderLibrary.extractParamNames(line)) + ");";
				
				functionBodyBuilder.append("@SuppressWarnings(\"unused\")\n")
						.append(functionSignature)
						.append(BuilderLibrary.formattingLines(functionTypeConversion, "\t", "\n"))
						.append(BuilderLibrary.formattingLine(functionCall, "\t", "\n"))
						.append(BuilderLibrary.formattingLine("}", "", "\n\n"));
			}
		});
		BuilderLibrary.appendStringBuilders(functionBodyBuilder, builder, "\t", "\n");
		builder.append("}");
		return builder;
	}
	
	/**
	 * Generation of the interface.
	 *
	 * @param functionsBuilder builder of functions
	 * @return the interface builder
	 */
	private static StringBuilder generateInterface(StringBuilder functionsBuilder) {
		StringBuilder builder = new StringBuilder();
		
		builder.append("""
				public interface MeosLibrary {
					functions.MeosLibrary INSTANCE = LibraryLoader.create(functions.MeosLibrary.class).load("meos");
					functions.MeosLibrary meos = functions.MeosLibrary.INSTANCE;
				""");
		BuilderLibrary.appendStringBuilders(functionsBuilder, builder, "\t", "\n");
		builder.append("}");
		return builder;
	}
	
	/**
	 * Generation of functions with their modified types.
	 *
	 * @return the function builder
	 */
	private static StringBuilder generateFunctions() {
		StringBuilder builder = new StringBuilder();
		
		BuilderLibrary.readFileLines(FunctionsBuilder.C_FUNCTIONS_PATH, line -> {
			String processedLine = performTypeConversion(line) + "\n";
			builder.append(processedLine);
		});
		System.out.println("Unsupported types: " + UNSUPPORTED_TYPES);
		return builder;
	}
	
	/**
	 * Process of adding code to handle conversion of certain types
	 *
	 * @param signature function signature
	 * @return the code to perform the type conversion
	 */
	private static List<String> getTypeConversionProcess(String signature) {
		ArrayList<String> lines = new ArrayList<>();
		List<Pair<String, String>> typesList = BuilderLibrary.extractParamTypesAndNames(signature);
		
		for (Pair<String, String> type : typesList) {
			String typeValue = type.key(); // Get the type value
			
			if (CONVERSION_PROCESS_TYPES.contains(typeValue)) {
				String typeName = type.value(); // Get the type name
				
				switch (typeValue) {
					case "LocalDateTime":
						lines.add("long " + typeName + " = " + typeName + ".toEpochSecond(java.time.ZoneOffset.UTC);");
						break;
					case "ZonedDateTime":
						lines.add("long " + typeName + " = " + typeName + ".toEpochSecond();");
						break;
					default:
						throw new TypeNotPresentException(typeValue, new Throwable("Type not supported by the builder conversion process"));
				}
			}
		}
		return lines;
	}
	
	/**
	 * Processes the rows to generate the functions.
	 *
	 * @param line the line corresponding to a function
	 * @return the processed line
	 */
	private static String performTypeConversion(String line) {
		if (!line.isBlank()) {
			// Remove keywords that are not of interest to us
			line = line.replaceAll("extern ", "");
			line = line.replaceAll("const ", "");
			line = line.replaceAll("static inline ", "");
			
			// Changing types with *
			line = line.replaceAll("char\\s\\*", "*char ");
			line = line.replaceAll("\\w+\\s\\*\\*", "*[] ");
			line = line.replaceAll("\\w+\\s\\*(?!\\*)", "* ");
			
			// Changing special types or names
			line = line.replaceAll("\\(void\\)", "()"); // Remove the void parameter (for the function meos_finish(void)) //FIXME utiliser les Optional pour les param optionel look pymeos
			line = line.replaceAll("synchronized", "synchronize"); // Change the keyword used by Java (for the function temporal_simplify(const Temporal *temp, double eps_dist, bool synchronized))
			
			// Replaces types from type dictionary
			for (Map.Entry<String, String> entry : TYPES_CONVERSION.entrySet()) {
				String oldType = entry.getKey();
				String newType = entry.getValue();
				line = line.replaceAll("(^|\\(|\\s)" + oldType + "(\\s|\\[\\])", "$1" + newType + "$2");
			}
			
			List<String> typesNotSupported = getFunctionTypes(line).stream().filter(type -> !TYPES_CONVERSION.containsValue(type)).toList(); // Retrieving unsupported types for the line
			UNSUPPORTED_TYPES.addAll(typesNotSupported.stream().filter(type -> !UNSUPPORTED_TYPES.contains(type)).toList()); // Fetch unsupported types that are not yet in the global list
		}
		
		return line;
	}
	
	/**
	 * Gives the types of the function's parameters and return from a line corresponding to the format of a function.
	 *
	 * @param signature function signature
	 * @return types list
	 */
	private static ArrayList<String> getFunctionTypes(String signature) {
		ArrayList<String> functionTypes = BuilderLibrary.extractFunctionTypes(signature);
		
		/* Remove Array Types from the functionTypes list then change it to normal type */
		List<String> arrayTypesList = functionTypes.stream().filter(type -> type.contains("[]")).toList();
		functionTypes.removeAll(arrayTypesList);
		
		List<String> newTypesList = arrayTypesList.stream().map(arrayType -> arrayType.replace("[]", "")).toList();
		functionTypes.addAll(newTypesList);
		
		return functionTypes;
	}
}