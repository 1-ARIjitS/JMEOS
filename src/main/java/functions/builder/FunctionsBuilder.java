package functions.builder;

import utils.builder.BuilderLibrary;
import utils.builder.Pair;

import java.nio.file.InvalidPathException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Class used to build the functions from the MEOS library.
 * Run with ./script folder
 *
 * @author Killian Monnier
 * @since 27/06/2a023
 */
public class FunctionsBuilder {
	private static final String BUILDER_PATH = "src/main/java/functions/builder/";
	private static final String C_FUNCTIONS_PATH = BUILDER_PATH + "tmp/meos_functions.h"; // File generated by the FunctionsExtractor class
	private static final String C_TYPES_PATH = BUILDER_PATH + "tmp/meos_types.h"; // File generated by the FunctionsExtractor class
	private static final String FUNCTIONS_CLASS_PATH = BUILDER_PATH + "../functions.java"; // Generated functions class
	private final HashMap<String, String> equivalentTypes = buildEquivalentTypes(); // Creation of the C type dictionary and its equivalent in Java
	private final ArrayList<String> unsupportedEquivalentTypes = new ArrayList<>(); // List of unsupported types
	private final ArrayList<String> unsupportedConversionTypedefs = new ArrayList<>(); // List of unsupported types
	private final HashMap<String, String> conversionTypes = buildConversionTypes(); // List of types to perform a conversion
	private final HashMap<String, String> conversionTypedefs = buildConversionTypedefs(); // List of types to perform a conversion
	private final ArrayList<String> unsupportedConversionTypes = new ArrayList<>(); // List of unsupported types
	
	/**
	 * Gives the types of the function's parameters and return from a line corresponding to the format of a function.
	 *
	 * @param signature Function signature
	 * @return Types list
	 */
	private static ArrayList<String> getFunctionTypes(String signature) {
		ArrayList<String> functionTypes = BuilderLibrary.extractFunctionTypes(signature);
		
		/* Remove Array Types from the functionTypes list then change it to normal type */
		List<String> arrayTypesList = functionTypes.stream().filter(type -> type.contains("[]")).toList();
		functionTypes.removeAll(arrayTypesList);
		
		List<String> newTypesList = arrayTypesList.stream().map(arrayType -> arrayType.replace("[]", "")).toList();
		functionTypes.addAll(newTypesList);
		
		return functionTypes;
	}
	
	/**
	 * Main script execution function.
	 *
	 * @param args Arguments
	 */
	public static void main(String[] args) {
		/* Retrieve the value of the JMEOS_PATH environment variable */
		String jmeosHome = System.getenv("JMEOS_HOME");
		
		/* Check if environment variable exists */
		if (jmeosHome != null) {
			System.out.println("JMEOS_HOME: " + jmeosHome);
			System.setProperty("user.dir", jmeosHome); // Set the current working directory
			
			FunctionsBuilder builder = new FunctionsBuilder();
			
			/* Generation of all the functions signature */
			StringBuilder functionsBuilder = builder.generateFunctions();
			StringBuilder functionsInterfaceBuilder = builder.generateInterfaceFunctions(functionsBuilder);
			StringBuilder functionsClassBuilder = builder.generateClassFunctions(functionsBuilder);
			System.out.println("Unsupported types: " + builder.unsupportedEquivalentTypes);
			System.out.println("Unsupported conversion typedefs: " + builder.unsupportedConversionTypedefs);
			System.out.println("Unsupported conversion types: " + builder.unsupportedConversionTypes);
			
			/* Generation of the file */
			StringBuilder interfaceBuilder = builder.generateInterface(functionsInterfaceBuilder);
			StringBuilder classBuilder = builder.generateClass(functionsClassBuilder, interfaceBuilder);
			BuilderLibrary.writeFileFromBuilder(classBuilder, FUNCTIONS_CLASS_PATH);
		} else {
			throw new InvalidPathException("JMEOS_HOME", "The JMEOS_HOME environment variable is not set.\nCancellation of build.");
		}
	}
	
	/**
	 * Builds the type modification array.
	 * <pre>
	 * Key: old type in C or modified
	 * Value: new type in Java
	 * </pre>
	 *
	 * @return Type dictionary
	 */
	private HashMap<String, String> buildEquivalentTypes() {
		HashMap<String, String> types = new HashMap<>();
		types.put("\\*", "Pointer");
		types.put("\\*char", "String");
		types.put("Pointer\\[\\]", "Pointer"); // Keep this line, otherwise operand error in JNR-FFI
		types.put("bool", "boolean");
		types.put("float", "float");
		types.put("double", "double");
		types.put("void", "void");
		types.put("int", "int");
		types.put("short", "short");
		types.put("long", "long");
		types.put("int8", "byte");
		types.put("int16", "short");
		types.put("int32", "int");
		types.put("int64", "long");
		types.put("int8_t", "byte");
		types.put("int16_t", "short");
		types.put("int32_t", "int");
		types.put("int64_t", "long");
		types.put("uint8", "byte");
		types.put("uint16", "short");
		types.put("uint32", "int");
		types.put("uint64", "long");
		types.put("uint8_t", "byte");
		types.put("uint16_t", "short");
		types.put("uint32_t", "int");
		types.put("uint64_t", "long");
		types.put("uintptr_t", "long");
		types.put("size_t", "long");
		types.put("interpType", "int"); // enum in C
		
		return types;
	}
	
	/**
	 * Build the dictionary of typedef conversion.
	 * <pre>
	 * Key: old type in C or modified
	 * Value: new type in Java
	 * </pre>
	 *
	 * @return types dictionary
	 */
	private HashMap<String, String> buildConversionTypedefs() {
		HashMap<String, String> typedefs = new HashMap<>();
		
		/* Added typedefs extracted from C file */
		BuilderLibrary.readFileLines(C_TYPES_PATH, line -> {
			Pattern pattern = Pattern.compile("^typedef\\s(\\w+)\\s(\\w+);");
			Matcher matcher = pattern.matcher(line);
			if (matcher.find()) {
				String rawType = matcher.group(1);
				String typeDef = matcher.group(2);
				
				typedefs.put(typeDef, rawType);
			} else {
				System.err.println("Cannot extract type for row: " + line);
			}
		});
		return typedefs;
	}
	
	/**
	 * Build the dictionary of conversion types.
	 * <pre>
	 * Key: old type in C or modified
	 * Value: new type in Java
	 * </pre>
	 *
	 * @return types dictionary
	 */
	private HashMap<String, String> buildConversionTypes() {
		HashMap<String, String> conversionTypes = new HashMap<>();
		conversionTypes.put("Timestamp", "LocalDateTime");
		conversionTypes.put("TimestampTz", "OffsetDateTime");
		return conversionTypes;
	}
	
	/**
	 * Used to generate the class of functions.
	 *
	 * @param functionsBuilder Builder of functions
	 * @param interfaceBuilder Interface builder
	 * @return The class builder
	 */
	private StringBuilder generateClass(StringBuilder functionsBuilder, StringBuilder interfaceBuilder) {
		StringBuilder builder = new StringBuilder();
		
		/* Get the package name */
		Package pkg = FunctionsBuilder.class.getPackage();
		String packageName = pkg.getName();
		String basePackage = packageName.substring(0, packageName.lastIndexOf('.'));
		String definePackage = "package " + basePackage + ";\n";
		
		String imports = """
				import jnr.ffi.Pointer;
				import utils.JarLibraryLoader;
				
				import java.time.LocalDateTime;
				import java.time.OffsetDateTime;
				""";
		String className = "public class functions {";
		builder.append(definePackage).append("\n").append(imports).append("\n").append(className).append("\n");
		
		/* Added interface */
		BuilderLibrary.appendStringBuilders(interfaceBuilder, builder, "\t", "\n\n");
		
		/* Addition of functions */
		StringBuilder functionBodyBuilder = new StringBuilder();
		BuilderLibrary.readBuilderLines(functionsBuilder, line -> {
			if (!line.isBlank()) {
				String functionSignature = "public static " + BuilderLibrary.removeSemicolon(line) + " {\n";
				List<String> functionTypeConversion = getTypeConversionProcess(line);
				
				String functionCall = "";
				if (!getFunctionTypes(line).get(0).equals("void")) // When return
					functionCall += "return ";
				functionCall += "MeosLibrary.meos." + BuilderLibrary.extractFunctionName(line) + "(" + BuilderLibrary.getListWithoutBrackets(BuilderLibrary.extractParamNames(line)) + ");";
				
				functionBodyBuilder.append("@SuppressWarnings(\"unused\")\n")
						.append(functionSignature)
						.append(BuilderLibrary.formattingLines(functionTypeConversion, "\t", "\n"))
						.append(BuilderLibrary.formattingLine(functionCall, "\t", "\n"))
						.append(BuilderLibrary.formattingLine("}", "", "\n\n"));
			}
		});
		BuilderLibrary.appendStringBuilders(functionBodyBuilder, builder, "\t", "\n");
		builder.append("}");
		return builder;
	}
	
	/**
	 * Generation of the interface.
	 *
	 * @param functionsBuilder Builder of functions
	 * @return The interface builder
	 */
	private StringBuilder generateInterface(StringBuilder functionsBuilder) {
		StringBuilder builder = new StringBuilder();
		
		builder.append("""
				public interface MeosLibrary {
					MeosLibrary INSTANCE = JarLibraryLoader.create(MeosLibrary.class, "meos").getLibraryInstance();
					MeosLibrary meos = MeosLibrary.INSTANCE;
				""");
		BuilderLibrary.appendStringBuilders(functionsBuilder, builder, "\t", "\n");
		builder.append("}");
		return builder;
	}
	
	/**
	 * Generation of functions with their equivalent types and typedef equivalent types.
	 *
	 * @return The function builder
	 *
	 * //TODO faire une fonction generique de celle-ci et generateClassFunction
	 */
	private StringBuilder generateInterfaceFunctions(StringBuilder functions) {
		StringBuilder builder = new StringBuilder();
		
		BuilderLibrary.readBuilderLines(functions, line -> {
			line = BuilderLibrary.replaceTypes(conversionTypedefs, line);
			unsupportedConversionTypedefs.addAll(getUnsupportedTypes(line, conversionTypedefs).stream().filter(type -> !unsupportedConversionTypedefs.contains(type)).toList());
			
			line = BuilderLibrary.replaceTypes(equivalentTypes, line);
			unsupportedEquivalentTypes.addAll(getUnsupportedTypes(line, equivalentTypes).stream().filter(type -> !unsupportedEquivalentTypes.contains(type)).toList());
			
			builder.append(BuilderLibrary.formattingLine(line, "", "\n"));
		});
		
		return builder;
	}
	
	/**
	 * Generation of functions with their equivalent types and typedef conversion types.
	 *
	 * @return The function builder
	 */
	private StringBuilder generateClassFunctions(StringBuilder functions) {
		StringBuilder builder = new StringBuilder();
		
		BuilderLibrary.readBuilderLines(functions, line -> {
			/* Replaces types from type dictionary */
			line = BuilderLibrary.replaceTypes(conversionTypes, line);
			/* Fetch unsupported types that are not yet in the global list */
			unsupportedConversionTypes.addAll(getUnsupportedTypes(line, conversionTypes).stream().filter(type -> !unsupportedConversionTypes.contains(type)).toList());
			
			/* Replaces types from type dictionary */
			line = BuilderLibrary.replaceTypes(equivalentTypes, line);
			/* Fetch unsupported types that are not yet in the global list */
			unsupportedEquivalentTypes.addAll(getUnsupportedTypes(line, equivalentTypes).stream().filter(type -> !unsupportedEquivalentTypes.contains(type)).toList());
			
			builder.append(BuilderLibrary.formattingLine(line, "", "\n"));
		});
		return builder;
	}
	
	/**
	 * Generation of functions with their equivalent types.
	 *
	 * @return The function builder
	 */
	private StringBuilder generateFunctions() {
		StringBuilder builder = new StringBuilder();
		
		BuilderLibrary.readFileLines(FunctionsBuilder.C_FUNCTIONS_PATH, line -> {
			String processedLine = performTypeConversion(line);
			builder.append(BuilderLibrary.formattingLine(processedLine, "", "\n"));
		});
		return builder;
	}
	
	/**
	 * Process of adding code to handle conversion of certain types
	 *
	 * @param signature Function signature
	 * @return The code to perform the type conversion
	 */
	private List<String> getTypeConversionProcess(String signature) {
		ArrayList<String> lines = new ArrayList<>();
		List<Pair<String, String>> typesList = BuilderLibrary.extractParamTypesAndNames(signature);
		
		/* For each types */
		for (Pair<String, String> type : typesList) {
			String typeValue = type.key();
			
			/* If this type needs a conversion */
			if (conversionTypes.containsValue(typeValue)) {
				String typeName = type.value();
				String newTypeName = typeName + "_new";
				
				switch (typeValue) {
					case "LocalDateTime" -> lines.add(newTypeName + " = " + typeName + ".toEpochSecond(java.time.ZoneOffset.UTC);");
					case "OffsetDateTime" -> lines.add(newTypeName + " = " + typeName + ".toEpochSecond();");
					default -> throw new TypeNotPresentException(typeValue, new Throwable("Type not supported by the builder conversion process"));
				}
			}
		}
		return lines;
	}
	
	/**
	 * Processes the rows to generate the functions.
	 *
	 * @param line The line corresponding to a function
	 * @return The processed line
	 */
	private static String performTypeConversion(String line) {
		if (!line.isBlank()) {
			/* Remove keywords that are not of interest to us */
			line = line.replaceAll("extern ", "");
			line = line.replaceAll("const ", "");
			line = line.replaceAll("static inline ", "");
			
			/* Changing types with * */
			line = line.replaceAll("char\\s\\*", "*char ");
			line = line.replaceAll("\\w+\\s\\*\\*", "*[] ");
			line = line.replaceAll("\\w+\\s\\*(?!\\*)", "* ");
			
			/* Changing special types or names */
			line = line.replaceAll("\\(void\\)", "()"); // Remove the void parameter (for the function meos_finish(void)) //FIXME utiliser les Optional pour les param optionel look pymeos
			line = line.replaceAll("synchronized", "synchronize"); // Change the keyword used by Java (for the function temporal_simplify(const Temporal *temp, double eps_dist, bool synchronized))
		}
		
		return line;
	}
	
	/**
	 * Check unsupported types.
	 *
	 * @param signature Function signature
	 */
	private List<String> getUnsupportedTypes(String signature, Map<String, String> types) {
		/* Retrieving unsupported types for the line */
		return getFunctionTypes(signature).stream().filter(type -> !types.containsValue(type)).toList();
	}
}