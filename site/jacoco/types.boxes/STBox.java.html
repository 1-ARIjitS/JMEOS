<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>STBox.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jmeos</a> &gt; <a href="index.source.html" class="el_package">types.boxes</a> &gt; <span class="el_source">STBox.java</span></div><h1>STBox.java</h1><pre class="source lang-java linenums">package types.boxes;

import jnr.ffi.Memory;
import jnr.ffi.Runtime;
import jnr.ffi.annotations.In;
import org.locationtech.jts.io.ParseException;
import types.TemporalObject;
import types.basic.tpoint.TPoint;
import types.collections.time.Time;
import jnr.ffi.Pointer;
import org.locationtech.jts.geom.Geometry;

import java.time.Duration;
import java.time.LocalDateTime;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import types.collections.time.tstzset;
import types.collections.time.tstzspan;
import types.collections.time.tstzspanset;
import functions.*;
import types.temporal.Temporal;
import utils.ConversionUtils;
import functions.functions;
import javax.naming.OperationNotSupportedException;


/**
 * Class for representing a spatio-temporal box. Temporal bounds may be inclusive or exclusive.
 * &lt;pre&gt;
 *     ``STBox`` objects can be created with a single argument of type string as in MobilityDB.
 *         &gt;&gt;&gt; STBox('STBOX ZT(((1.0,2.0,3.0),(4.0,5.0,6.0)),[2001-01-01, 2001-01-02])')
 *&lt;/pre&gt;
 * &lt;pre&gt;
 *     Another possibility is to provide the different dimensions with the corresponding parameters:
 *         - ``xmin``, ``xmax``, ``ymin``, ``ymax`` for spatial dimension
 *         - ``zmin``, ``zmax`` for the third spatial dimension
 *         - ``tmin``, ``tmax`` for temporal dimension
 *         - ``tmin_inc``, ``tmax_inc`` to specify if the temporal bounds are inclusive or exclusive
 *         - ``geodetic`` to specify if the spatial dimension is geodetic
 *         - ``srid`` to specify the spatial reference system identifier
 *&lt;/pre&gt;
 *     Note that at least the 2D spatial dimension or the temporal dimension must be provided.
 *&lt;p&gt;
 *         &gt;&gt;&gt; STBox(xmin=1.0, xmax=4.0, ymin=2.0, ymax=5.0, tmin=datetime(2001, 1, 1), tmax=datetime(2001, 1, 2))
 *
 * @author ARIJIT SAMAL
 */
public class STBox implements Box {
<span class="pc" id="L52">	private final OffsetDateTime tMin = null;</span>
<span class="pc" id="L53">	private final OffsetDateTime tMax = null;</span>
<span class="pc" id="L54">	private boolean isGeodetic = false;</span>
<span class="pc" id="L55">	private final int srid = 0;</span>
<span class="pc" id="L56">	private Pointer _inner = null;</span>
<span class="pc" id="L57">	private boolean tmin_inc = true;</span>
<span class="pc" id="L58">	private boolean tmax_inc = true;</span>

	public STBox _get_box(TemporalObject other){
<span class="nc" id="L61">		return this._get_box(other,true,false);</span>
	}


	/**
	 * Factory method to create new STBox objects
	 *
	 * @param other a temporal object
	 * @param allow_space_only boolean space dimension
	 * @param allow_time_only boolean time dimension
	 * @return a new {@link STBox} object
	 */
	public STBox _get_box(Object other, boolean allow_space_only, boolean allow_time_only){
<span class="fc" id="L74">		STBox other_box=null;</span>
<span class="pc bpc" id="L75" title="2 of 4 branches missed.">		if(allow_space_only &amp;&amp; other instanceof Geometry){</span>
<span class="nc" id="L76">			other_box = new STBox(functions.geo_to_stbox(ConversionUtils.geo_to_gserialized((Geometry) other, this.geodetic())));</span>
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">		} else if (other instanceof TPoint) {</span>
<span class="nc" id="L78">			other_box = new STBox(functions.tpoint_to_stbox(((TPoint)other).getPointInner()));</span>
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">		} else if (allow_time_only) {</span>
<span class="pc bpc" id="L80" title="5 of 6 branches missed.">			switch (other) {</span>
<span class="fc" id="L81">				case STBox st -&gt; other_box = new STBox(st.get_inner());</span>
<span class="nc" id="L82">				case tstzset p -&gt; other_box = new STBox(functions.tstzset_to_stbox(p.get_inner()));</span>
<span class="nc" id="L83">				case tstzspan ps -&gt; other_box = new STBox(functions.tstzspan_to_stbox(ps.get_inner()));</span>
<span class="nc" id="L84">				case Temporal t -&gt; other_box = new STBox(functions.tstzset_to_stbox(functions.temporal_to_tstzspan(t.getInner())));</span>
<span class="nc" id="L85">				case tstzspanset ts -&gt; other_box = new STBox(functions.tstzspanset_to_stbox(ts.get_inner()));</span>
<span class="nc" id="L86">				default -&gt; throw new TypeNotPresentException(other.getClass().toString(), new Throwable(&quot;Operation not supported with this type&quot;));</span>
			}
		}
<span class="fc" id="L89">		return other_box;</span>
	}

    /* ------------------------- Constructors ---------------------------------- */


	/**
	 * The default constructor
	 */
<span class="nc" id="L98">	public STBox() {</span>

<span class="nc" id="L100">	}</span>
	
	public STBox(Pointer inner){
<span class="fc" id="L103">		this(inner, true, true, false);</span>
<span class="fc" id="L104">	}</span>
	
<span class="fc" id="L106">	public STBox(Pointer inner, boolean tmin_inc, boolean tmax_inc, boolean geodetic){</span>
<span class="fc" id="L107">		this._inner = inner;</span>
<span class="fc" id="L108">		this.tmin_inc = tmin_inc;</span>
<span class="fc" id="L109">		this.tmax_inc = tmax_inc;</span>
<span class="fc" id="L110">		this.isGeodetic = geodetic;</span>
<span class="fc" id="L111">	}</span>

	/**
	 * The string constructor
	 *
	 * @param value - STBox value
	 */

<span class="fc" id="L119">	public STBox(final String value){</span>
<span class="fc" id="L120">		this._inner = functions.stbox_in(value);</span>
<span class="fc" id="L121">	}</span>

	/**
	 * Constructor with x,y,z coordinates and {@link LocalDateTime} values.
	 * @param xmin x minimum float value
	 * @param xmax x maximum float value
	 * @param ymin y minimum float value
	 * @param ymax y maximum float value
	 * @param zmin z minimum float value
	 * @param zmax z maximum float value
	 * @param tmin LocalDateTime minimum value
	 * @param tmax LocalDateTime maximum value
	 * @param tmin_inc tmin boolean inclusion
	 * @param tmax_inc tmax boolean inclusion
	 * @param geodetic boolean geodetic
	 */
<span class="nc" id="L137">	public STBox(float xmin, float xmax, float ymin, float ymax, float zmin, float zmax, LocalDateTime tmin, LocalDateTime tmax, boolean tmin_inc, boolean tmax_inc, boolean geodetic){</span>
<span class="nc" id="L138">		Pointer tstzspan=null;</span>
<span class="nc bnc" id="L139" title="All 4 branches missed.">		boolean hast = tmin != null &amp;&amp; tmax != null;</span>
<span class="nc bnc" id="L140" title="All 8 branches missed.">		boolean hasx = !Float.isNaN(xmin) &amp;&amp; !Float.isNaN(xmax) &amp;&amp; !Float.isNaN(ymin) &amp;&amp; !Float.isNaN(ymax);</span>
<span class="nc bnc" id="L141" title="All 4 branches missed.">		boolean hasz = !Float.isNaN(zmin) &amp;&amp; !Float.isNaN(zmax);</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">		if (hast){</span>
<span class="nc" id="L143">			tstzspan = new tstzspan(tmin, tmax, tmin_inc, tmax_inc).get_inner();</span>
		}

<span class="nc" id="L146">		this._inner = functions.stbox_make(hasx, hasz, geodetic, srid, xmin, xmax, ymin, ymax, zmin, zmax, tstzspan);</span>
<span class="nc" id="L147">	}</span>


	/**
	 * Constructor without the z coordinate
	 * @param xmin y minimum float value
	 * @param xmax y maximum float value
	 * @param ymin z minimum float value
	 * @param ymax z maximum float value
	 * @param tmin LocalDateTime minimum value
	 * @param tmax LocalDateTime maximum value
	 */
	public STBox(float xmin, float xmax, float ymin, float ymax, LocalDateTime tmin, LocalDateTime tmax){
<span class="nc" id="L160">		this(xmin,xmax,ymin,ymax,0.0f,0.0f,tmin,tmax,true,true,false);</span>
<span class="nc" id="L161">	}</span>


    /**
     * Constructor without the LocalDateTime aspect (equivalent to a TBox)
     * @param xmin
     * @param xmax
     * @param ymin
     * @param ymax
     * @param zmin
     * @param zmax
     */
	public STBox(float xmin, float xmax, float ymin, float ymax, float zmin, float zmax){
<span class="nc" id="L174">		this(xmin,xmax,ymin,ymax,zmin,zmax,null,null,true,true,false);</span>
<span class="nc" id="L175">	}</span>

	/**
	 * Constructor only with x coordinates and temporal dimension
	 * @param xmin
	 * @param xmax
	 * @param tmin
	 * @param tmax
	 */
	public STBox(float xmin, float xmax, LocalDateTime tmin, LocalDateTime tmax){
<span class="nc" id="L185">		this(xmin,xmax,0.0f,0.0f,0.0f,0.0f,tmin,tmax,true,true,false);</span>
<span class="nc" id="L186">	}</span>




	/**
	 * Returns a copy of &quot;this&quot;.
	 *&lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;stbox_copy&lt;/li&gt;
	 * @return a STBox instance
	 */
	public STBox copy() {
<span class="fc" id="L199">		return new STBox(functions.stbox_copy(this._inner));</span>
	}

	/**
	 * Returns a &quot;STBox&quot; from its WKB representation in hex-encoded ASCII.
	 *&lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;stbox_from_hexwkb&lt;/li&gt;
	 * @param hexwkb WKB representation in hex-encoded ASCII
	 * @return a new STBox instance
	 */
	public static STBox from_hexwkb(String hexwkb) {
<span class="nc" id="L211">		Pointer result = functions.stbox_from_hexwkb(hexwkb);</span>
<span class="nc" id="L212">		return new STBox(result);</span>
	}


	/**
	 * Returns a &quot;STBox&quot; from a &quot;Geometry&quot;.
	 * &lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;gserialized_in, geo_to_stbox &lt;/li&gt;
	 *
	 * @param geom A `Geometry` instance.
	 * @param geodetic Whether to create a geodetic or geometric `STBox`.
	 * @return a new STBox instance
	 */
	public static STBox from_geometry(Geometry geom, boolean geodetic) {
<span class="nc" id="L227">		return new STBox(functions.geo_to_stbox(ConversionUtils.geo_to_gserialized(geom,geodetic)));</span>
	}

	public static STBox from_geometry(Geometry geom) {
<span class="fc" id="L231">		boolean geodetic = false;</span>
<span class="fc" id="L232">		return new STBox(functions.geo_to_stbox(ConversionUtils.geo_to_gserialized(geom,geodetic)));</span>
	}


	/**
	 * Returns a &quot;STBox&quot; from a &quot;Time&quot; instance.
	 *&lt;p&gt;
	 *         MEOS Functions:
	 *         &lt;ul&gt;
	 *             &lt;li&gt;timestamp_to_stbox&lt;/li&gt;
	 *             &lt;li&gt;tstzspanset_to_stbox&lt;/li&gt;
	 *             &lt;li&gt;tstzset_to_stbox&lt;/li&gt;
	 *             &lt;li&gt;tstzspan_to_stbox&lt;/li&gt;
	 *         &lt;/ul&gt;
	 * @param other a Time instance
	 * @return a new STBox instance
	 */
	public static STBox from_time(Time other) {
		STBox returnValue;
<span class="nc bnc" id="L251" title="All 4 branches missed.">		switch (other){</span>
<span class="nc" id="L252">			case tstzset p -&gt; returnValue = new STBox(functions.tstzset_to_stbox(p.get_inner()));</span>
<span class="nc" id="L253">			case tstzspan ps -&gt; returnValue = new STBox(functions.tstzspan_to_stbox(ps.get_inner()));</span>
<span class="nc" id="L254">			case tstzspanset ts -&gt; returnValue = new STBox(functions.tstzspanset_to_stbox(ts.get_inner()));</span>
<span class="nc" id="L255">			default -&gt; throw new TypeNotPresentException(other.getClass().toString(), new Throwable(&quot;Operation not supported with this type&quot;));</span>
		}
<span class="nc" id="L257">		return returnValue;</span>
	}
	
	/*
	public STBox from_expanding_bounding_box_geom(Geometry value, float expansion) {
		Pointer gs = functions.gserialized_in(value.toString(), -1);
		Pointer result = functions.geo_expand_spatial(gs, expansion);
		return new STBox(result);
	}

	 */


    /* Modify Tpoint type
    public STBox from_expanding_bounding_box_tpoint(TPoint value, float expansion){
        Pointer result = tpoint_expand_spatial(value._inner, expansion);
        return new STBox(result);
    }

     */

    /*
    //Modify the from geometry datetime function
    public STBox from_space_datetime(Geometry value, Pointer time){
        return from_geometry_datetime(value,time);
    }

    public STBox from_space_tstzset(Geometry value, Pointer time ){
        return from_geometry_tstzset(value,time);
    }

     */


	/**
	 * Returns a &quot;STBox&quot; from a space and time dimension.
	 *
	 * &lt;p&gt;
	 *
	 *         MEOS Functions:
	 *             &lt;li&gt;geo_timestamp_to_stbox&lt;/li&gt;
	 *             &lt;li&gt;geo_tstzset_to_stbox&lt;/li&gt;
	 * @param geometry A {@link Geometry} instance representing the space dimension.
	 * @param datetime A `{@link Time} instance representing the time dimension.
	 * @param geodetic Whether to create a geodetic or geometric &quot;STBox&quot;.
	 * @return A new {@link STBox} instance.
	 */
	public static STBox from_geometry_datetime(Geometry geometry, LocalDateTime datetime, boolean geodetic){
<span class="nc" id="L305">        Pointer gs = ConversionUtils.geo_to_gserialized(geometry,geodetic);</span>
<span class="nc" id="L306">        Pointer result = functions.geo_timestamptz_to_stbox(gs,ConversionUtils.datetimeToTimestampTz(datetime));</span>
<span class="nc" id="L307">        return new STBox(result);</span>
    }


	/**
	 * Returns a &quot;STBox&quot; from a space and time dimension.
	 *
	 * &lt;p&gt;
	 *
	 *         MEOS Functions:
	 *             &lt;li&gt;geo_timestamp_to_stbox&lt;/li&gt;
	 *             &lt;li&gt;geo_tstzset_to_stbox&lt;/li&gt;
	 * @param geometry A {@link Geometry} instance representing the space dimension.
	 * @param tstzset A `{@link tstzset} instance representing the time dimension.
	 * @param geodetic Whether to create a geodetic or geometric &quot;STBox&quot;.
	 * @return A new {@link STBox} instance.
	 */
    public static STBox from_geometry_tstzspan(Geometry geometry, tstzset tstzset, boolean geodetic){
<span class="nc" id="L325">		Pointer gs = ConversionUtils.geo_to_gserialized(geometry,geodetic);</span>
<span class="nc" id="L326">        Pointer result = functions.geo_tstzspan_to_stbox(gs,tstzset.get_inner());</span>
<span class="nc" id="L327">        return new STBox(result);</span>
    }


	/**
	 * Returns the bounding box of a &quot;TPoint&quot; instance as an &quot;STBox&quot;.
	 *
	 * &lt;p&gt;.
	 *
	 *         MEOS Functions:
	 *             &lt;li&gt;tpoint_to_stbox&lt;/li&gt;
	 * @param temporal A {@link TPoint} instance.
	 * @return A new {@link STBox} instance.
	 */
    public static STBox from_tpoint(TPoint temporal){
<span class="nc" id="L342">        return new STBox(functions.tpoint_to_stbox(temporal.getPointInner()));</span>
    }


    /* ------------------------- Output ---------------------------------------- */

	/**
	 *  Returns a string representation of &quot;this&quot;.
	 *&lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;stbox_out&lt;/li&gt;
	 * @param max_decimals number of decimals
	 * @return a String instance
	 */
	public String toString(int max_decimals){
<span class="fc" id="L357">		return functions.stbox_out(this._inner,max_decimals);</span>
	}



    /* ------------------------- Conversions ---------------------------------- */

	/**
	 * Returns the temporal dimension of &quot;this&quot; as a &quot;tstzset&quot; instance.
	 * &lt;p&gt;
	 * MEOS Functions:
	 * &lt;li&gt;stbox_to_tstzset&lt;/li&gt;
	 *
	 * @return a new tstzset instance
	 */
    public tstzset to_tstzspan() {
<span class="nc" id="L373">        Pointer result = functions.stbox_to_tstzspan(this._inner);</span>
<span class="nc" id="L374">        return new tstzset(result);</span>
    }


	/**
	 * Returns the spatial dimension of &quot;this&quot; as a {@link Geometry} instance.
	 *
	 * &lt;p&gt;
	 *
	 *         MEOS Functions:
	 *             &lt;li&gt;stbox_to_geo&lt;/li&gt;
	 * @param precision The precision of the geometry coordinates.
	 * @return A new {@link Geometry} instance.
	 * @throws ParseException
	 */
	public Geometry to_geometry(int precision) throws ParseException {
<span class="fc" id="L390">		return ConversionUtils.gserialized_to_shapely_geometry(functions.stbox_to_geo(this._inner),precision);</span>
	}


    /* ------------------------- Accessors ------------------------------------- */

	/**
	 * Returns whether &quot;this&quot; has a spatial (XY) dimension.
	 *&lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;stbox_hasx&lt;/li&gt;
	 * @return True if &quot;this&quot; has a spatial dimension, False otherwise.
	 */
	public boolean has_xy() {
<span class="fc" id="L404">		return functions.stbox_hasx(this._inner);</span>
	}


	/**
	 * Returns whether &quot;this&quot; has a Z dimension.
	 *&lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;stbox_hasz&lt;/li&gt;
	 * @return True if &quot;this&quot; has a Z dimension, False otherwise.
	 */
	public boolean has_z() {
<span class="fc" id="L416">		return functions.stbox_hasz(this._inner);</span>
	}


	/**
	 * Returns whether &quot;this&quot; has a time dimension.
	 *&lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;stbox_hast&lt;/li&gt;
	 * @return True if &quot;this&quot; has a time dimension, False otherwise.
	 */
	public boolean has_t() {
<span class="fc" id="L428">		return functions.stbox_hast(this._inner);</span>
	}

	/**
	 * Returns whether &quot;this&quot; is geodetic.
	 *&lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt; stbox_isgeodetic &lt;/li&gt;
	 * @return True if &quot;this&quot; is geodetic, False otherwise.
	 */
	public boolean geodetic() {
<span class="fc" id="L439">		return functions.stbox_isgeodetic(this._inner);</span>
	}


	/**
	 * Returns the minimum X coordinate of &quot;this&quot;.
	 *
	 * &lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;stbox_xmin&lt;/li&gt;
	 * @return A {@link Float} with the minimum X coordinate of &quot;this&quot;.
	 */
    public float xmin(){
<span class="nc" id="L452">		return (float) functions.stbox_xmin(this._inner).getDouble(0);</span>
    }

	/**
	 * Returns the minimum Y coordinate of &quot;this&quot;.
	 *
	 * &lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;stbox_ymin&lt;/li&gt;
	 * @return A {@link Float} with the minimum Y coordinate of &quot;this&quot;.
	 */
    public float ymin(){
<span class="nc" id="L464">		return (float) functions.stbox_ymin(this._inner).getDouble(0);</span>
    }

	/**
	 * Returns the minimum Z coordinate of &quot;this&quot;.
	 *
	 * &lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;stbox_zmin&lt;/li&gt;
	 * @return A {@link Float} with the minimum Z coordinate of &quot;this&quot;.
	 */
    public float zmin(){
<span class="nc" id="L476">		return (float) functions.stbox_zmin(this._inner).getDouble(0);</span>
    }

	/**
	 * Returns the minimum T coordinate of &quot;this&quot;.
	 *
	 * &lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;stbox_tmin&lt;/li&gt;
	 * @return A {@link Float} with the minimum T coordinate of &quot;this&quot;.
	 */
    public float tmin(){
<span class="nc" id="L488">		return (float) functions.stbox_tmin(this._inner).getDouble(0);</span>
    }

	/**
	 * Returns the maximum X coordinate of &quot;this&quot;.
	 *
	 * &lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;stbox_xmax&lt;/li&gt;
	 * @return A {@link Float} with the maximum X coordinate of &quot;this&quot;.
	 */
    public float xmax(){
<span class="nc" id="L500">		return (float) functions.stbox_xmax(this._inner).getDouble(0);</span>
    }

	/**
	 * Returns the maximum Y coordinate of &quot;this&quot;.
	 *
	 * &lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;stbox_ymax&lt;/li&gt;
	 * @return A {@link Float} with the maximum Y coordinate of &quot;this&quot;.
	 */
    public float ymax(){
<span class="nc" id="L512">		return (float) functions.stbox_ymax(this._inner).getDouble(0);</span>
    }

	/**
	 * Returns the maximum Z coordinate of &quot;this&quot;.
	 *
	 * &lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;stbox_zmax&lt;/li&gt;
	 * @return A {@link Float} with the maximum Z coordinate of &quot;this&quot;.
	 */
    public float zmax(){
<span class="nc" id="L524">		return (float) functions.stbox_zmax(this._inner).getDouble(0);</span>
    }

	/**
	 * Returns the maximum T coordinate of &quot;this&quot;.
	 *
	 * &lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;stbox_tmax&lt;/li&gt;
	 * @return A {@link Float} with the maximum T coordinate of &quot;this&quot;.
	 */
    public float tmax(){
<span class="nc" id="L536">		return (float) functions.stbox_tmax(this._inner).getDouble(0);</span>
    }

	public boolean get_tmin_inc(){
<span class="nc" id="L540">		return tmin_inc;</span>
	}

	public boolean get_tmax_inc(){
<span class="nc" id="L544">		return tmax_inc;</span>
	}

	public OffsetDateTime getTMin() {
<span class="nc" id="L548">		return tMin;</span>
	}

	public OffsetDateTime getTMax() {
<span class="nc" id="L552">		return tMax;</span>
	}

	public boolean isGeodetic() {
<span class="nc" id="L556">		return isGeodetic;</span>
	}

	public int getSrid() {
<span class="nc" id="L560">		return srid;</span>
	}

	public Pointer get_inner(){
<span class="fc" id="L564">		return this._inner;</span>
	}


    /* ------------------------- Spatial Reference System ---------------------- */

	/**
	 * Returns the SRID of &quot;this&quot;.
	 *&lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;stbox_srid&lt;/li&gt;
	 * @return an Integer with the SRID of &quot;this&quot;
	 */
	public int srid(){
<span class="fc" id="L578">		return functions.stbox_srid(this._inner);</span>
	}


	/**
	 * Returns a copy of &quot;this&quot; with the SRID set to &quot;value&quot;.
	 *&lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;stbox_set_srid&lt;/li&gt;
	 * @param value The new SRID.
	 * @return a new STBox instance
	 */
	public STBox set_srid(int value) {
<span class="fc" id="L591">		return new STBox(functions.stbox_set_srid(this._inner,value));</span>
	}
	

	/* ------------------------- Transformations ------------------------------- */

	/**
	 * Get the spatial dimension of &quot;this&quot;, removing the temporal dimension
	 *         if any
	 *
	 * &lt;p&gt;
	 *
	 *         MEOS Functions:
	 *             &lt;li&gt;stbox_get_space&lt;/li&gt;
	 * @return A new {@link STBox} instance.
	 */
	public STBox get_space(){
<span class="nc" id="L608">		return new STBox(functions.stbox_get_space(this._inner));</span>
	}


	/**
	 * Expands &quot;this&quot; with &quot;other&quot;.
	 *         If &quot;other&quot; is a {@link Integer} or a {@link Float}, the result is equal
	 *         to &quot;this&quot; but with the spatial dimensions expanded by &quot;other&quot; in all
	 *         directions. If &quot;other&quot; is a {@link java.time.Duration}, the result is equal to
	 *         &quot;this&quot;  but with the temporal dimension expanded by `other` in both
	 *         directions.
	 *
	 * &lt;p&gt;
	 *
	 *         MEOS Functions:
	 *             &lt;li&gt;stbox_expand_space&lt;/li&gt;
	 *             &lt;li&gt;stbox_expand_time&lt;/li&gt;
	 * @param stbox The object to expand &quot;this&quot; with.
	 * @param other The object to expand &quot;this&quot; with.
	 * @return A new {@link STBox} instance.
	 */
	public STBox expand_stbox(STBox stbox, STBox other) {
<span class="nc" id="L630">		Pointer result = functions.stbox_copy(this._inner);</span>
//		functions.stbox_expand_space(other._inner, result);
<span class="nc" id="L632">		return new STBox(result);</span>
	}


	/**
	 * Expands &quot;this&quot; with &quot;other&quot;.
	 *         If &quot;other&quot; is a {@link Integer} or a {@link Float}, the result is equal
	 *         to &quot;this&quot; but with the spatial dimensions expanded by &quot;other&quot; in all
	 *         directions. If &quot;other&quot; is a {@link java.time.Duration}, the result is equal to
	 *         &quot;this&quot;  but with the temporal dimension expanded by `other` in both
	 *         directions.
	 *
	 * &lt;p&gt;
	 *
	 *         MEOS Functions:
	 *             &lt;li&gt;stbox_expand_space&lt;/li&gt;
	 *             &lt;li&gt;stbox_expand_time&lt;/li&gt;
	 * @param value The value to expand with
	 * @return A new {@link STBox} instance.
	 */
	public STBox expand_numerical(Number value) {
<span class="fc" id="L653">		STBox result = null;</span>
<span class="pc bpc" id="L654" title="3 of 4 branches missed.">		if(value instanceof Integer || value instanceof Float){</span>
<span class="fc" id="L655">			result = new STBox(functions.stbox_expand_space(this.get_inner(), (double) value.floatValue()));</span>
		}
<span class="fc" id="L657">		return result;</span>
	}


	/**
	 * Returns &quot;this&quot; rounded to the given number of decimal digits.
	 *&lt;p&gt;
	 *         MEOS Functions:
	 *            &lt;li&gt;stbox_round &lt;/li&gt;
	 *
	 * @param maxdd Maximum number of decimal digits.
	 * @return a new STBox instance
	 */
	public STBox round(int maxdd) {
<span class="nc" id="L671">		Pointer new_inner = functions.stbox_copy(this._inner);</span>
<span class="nc" id="L672">		functions.stbox_round(new_inner,maxdd);</span>
<span class="nc" id="L673">		return new STBox(new_inner);</span>
	}






    /* ------------------------- Set Operations -------------------------------- */


	/**
	 * Returns the union of &quot;this&quot; with &quot;other&quot;. Fails if the union is not contiguous.
	 *&lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;union_stbox_stbox&lt;/li&gt;
	 * @param other spatiotemporal box to merge with
	 * @param strict included or not
	 * @return a new STBox instance
	 */
	public STBox union(STBox other, boolean strict) {
<span class="nc" id="L694">		return new STBox(functions.union_stbox_stbox(this._inner, other._inner, strict));</span>
	}


	/**
	 * Returns the union of &quot;this&quot; with &quot;other&quot;. Fails if the union is not contiguous.
	 *&lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;union_stbox_stbox&lt;/li&gt;
	 * @param other spatiotemporal box to merge with
	 * @return a new STBox instance
	 */
	public STBox add(STBox other) {
<span class="nc" id="L707">		return this.union(other, true);</span>
	}


	/**
	 * Returns the intersection of &quot;this&quot; with &quot;other&quot;.
	 *&lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;intersection_stbox_stbox &lt;/li&gt;
	 *
	 * @param other temporal object to merge with
	 * @return a new STBox instance if the instersection is not empty, `None` otherwise.
	 */
	public STBox intersection(STBox other) {
<span class="nc" id="L721">		return new STBox(functions.intersection_stbox_stbox(this._inner,other.get_inner()));</span>
	}


	/**
	 * Returns the intersection of &quot;this&quot; with &quot;other&quot;.
	 *&lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;intersection_stbox_stbox &lt;/li&gt;
	 *
	 * @param other temporal object to merge with
	 * @return a new STBox instance if the instersection is not empty, `None` otherwise.
	 */
	public STBox mul(STBox other) {
<span class="nc" id="L735">		return this.intersection(other);</span>
	}




	/* ------------------------- Positions Operators ------------------------------------- */



	/**
	 * Returns whether ``self`` and `other` are adjacent. Two spatiotemporal boxes are adjacent if they share n
	 *         dimensions and the intersection is of at most n-1 dimensions. Note that for `TPoint` instances, the bounding box
	 *         of the temporal point is used.
	 *&lt;p&gt;&lt;/p&gt;
	 *&lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;adjacent_stbox_stbox&lt;/li&gt;
	 * @param other The other spatiotemporal object to check adjacency with &quot;this&quot;.
	 * @return &quot;true&quot; if &quot;this&quot; and &quot;other&quot; are adjacent, &quot;false&quot; otherwise.
	 */
	public boolean is_adjacent(TemporalObject other) {
<span class="fc" id="L757">		return functions.adjacent_stbox_stbox(this._inner,this._get_box(other,true,true).get_inner());</span>
	}

	/**
	 * Returns whether &quot;this&quot; is contained in &quot;other&quot;. Note that for &quot;TPoint&quot; instances, the bounding
	 *         box of the temporal point is used.
	 *&lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;contained_stbox_stbox&lt;/li&gt;
	 * @param other The spatiotemporal object to check containment with &quot;this.
	 * @return &quot;true&quot; if &quot;this&quot; is contained in &quot;other&quot;, &quot;false&quot; otherwise.
	 */
	public boolean is_contained_in(TemporalObject other) {
<span class="nc" id="L770">		return functions.contained_stbox_stbox(this._inner,this._get_box(other,true,true).get_inner());</span>
	}

	/**
	 * Returns whether &quot;this&quot; contains `content`. Note that for &quot;TPoint&quot; instances, the bounding box of
	 *         the temporal point is used.
	 *
	 *  &lt;p&gt;
	 *
	 *         MEOS Functions:
	 *             &lt;li&gt;contains_stbox_stbox &lt;/li&gt;
	 * @param other The spatiotemporal object to check containment with &quot;this&quot;.
	 * @return &quot;true&quot; if &quot;this&quot; contains &quot;other&quot;, &quot;false otherwise.
	 */
	public boolean contains(TemporalObject other) {
<span class="nc" id="L785">		return functions.contains_stbox_stbox(this._inner,this._get_box(other,true,true).get_inner());</span>
	}

	/**
	 * Returns whether &quot;this&quot; overlaps &quot;other&quot;. Note that for &quot;TPoint&quot; instances, the bounding box of
	 *         the temporal point is used.
	 *&lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;overlaps_stbox_stbox &lt;/li&gt;
	 * @param other The spatiotemporal object to check overlap with &quot;this&quot;.
	 * @return &quot;true&quot; if &quot;this&quot; overlaps &quot;other&quot;, &quot;false&quot; otherwise.
	 */
	public boolean overlaps(TemporalObject other)  {
<span class="nc" id="L798">		return functions.overlaps_stbox_stbox(this._inner,this._get_box(other,true,true).get_inner());</span>
	}

	/**
	 * Returns whether &quot;this&quot; is the same as &quot;other&quot;. Note that for &quot;TPoint&quot; instances, the bounding box of
	 *         the temporal point is used.
	 *&lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;same_stbox_stbox&lt;/li&gt;
	 * @param other The spatiotemporal object to check equality with &quot;this&quot;.
	 * @return &quot;true&quot; if &quot;this&quot; is the same as &quot;other&quot;, &quot;false&quot; otherwise.
	 */
	public boolean is_same(TemporalObject other) {
<span class="nc" id="L811">		return functions.same_stbox_stbox(this._inner,this._get_box(other,true,true).get_inner());</span>
	}

	/**
	 * Returns whether &quot;this&quot; is strictly to the left  of &quot;other&quot;. Checks the X dimension.
	 *
	 * &lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;left_stbox_stbox &lt;/li&gt;
	 * @param other The spatiotemporal object to compare with &quot;this&quot;.
	 * @return &quot;true&quot; if &quot;this&quot; is strictly to the left of &quot;other&quot;, &quot;false&quot; otherwise.
	 */
	public boolean is_left(TemporalObject other) {
<span class="nc" id="L824">		return functions.left_stbox_stbox(this._inner,this._get_box(other).get_inner());</span>
	}

	/**
	 * Returns whether &quot;this&quot; is to the left &quot;other&quot; allowing for overlap. That is, &quot;this&quot; does not extend
	 *         to the right of &quot;other. Checks the X dimension.
	 *&lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;overleft_stbox_stbox, tpoint_to_stbox&lt;/li&gt;
	 * @param other The spatiotemporal object to compare with &quot;this&quot;.
	 * @return &quot;true&quot; if &quot;this&quot; is to the left of &quot;other&quot;, &quot;false&quot; otherwise.
	 */
	public boolean is_over_or_left(TemporalObject other) {
<span class="nc" id="L837">		return functions.overleft_stbox_stbox(this._inner,this._get_box(other).get_inner());</span>
	}

	/**
	 * Returns whether &quot;this&quot; is strictly to the right of &quot;other&quot;. Checks the X dimension.
	 *
	 * &lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;right_stbox_stbox&lt;/li&gt;
	 * @param other The spatiotemporal object to compare with &quot;this&quot;.
	 * @return &quot;true&quot; if &quot;this&quot; is strictly to the right of &quot;other&quot;, &quot;false&quot; otherwise.
	 */
	public boolean is_right(TemporalObject other) {
<span class="nc" id="L850">		return functions.right_stbox_stbox(this._inner,this._get_box(other).get_inner());</span>
	}

	/**
	 * Returns whether &quot;this&quot; is to the right of &quot;other&quot; allowing for overlap. That is, &quot;this&quot; does not
	 *         extend to the left of &quot;other&quot;. Checks the X dimension.
	 *
	 * &lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;overright_stbox_stbox&lt;/li&gt;
	 * @param other The spatiotemporal object to compare with &quot;this&quot;.
	 * @return &quot;true&quot; if &quot;this&quot; is to the right of &quot;other&quot;, &quot;false&quot; otherwise.
	 */
	public boolean is_over_or_right(TemporalObject other) {
<span class="nc" id="L864">		return functions.overright_stbox_stbox(this._inner,this._get_box(other).get_inner());</span>
	}

	/**
	 * Returns whether &quot;this&quot; is strictly below &quot;other&quot;. Checks the Y dimension.
	 *
	 * &lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;below_stbox_stbox&lt;/li&gt;
	 * @param other The spatiotemporal object to compare with &quot;this&quot;.
	 * @return &quot;true&quot; if &quot;this&quot; is strictly below of &quot;other&quot;, &quot;false&quot; otherwise.
	 */
	public boolean is_below(TemporalObject other) {
<span class="nc" id="L877">		return functions.below_stbox_stbox(this._inner,this._get_box(other).get_inner());</span>
	}


	/**
	 * Returns whether &quot;this&quot; is below &quot;other&quot; allowing for overlap. That is, &quot;this&quot; does not extend
	 *         above &quot;other&quot;. Checks the Y dimension.
	 *
	 * &lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;overbelow_stbox_stbox&lt;/li&gt;
	 * @param other The spatiotemporal object to compare with &quot;this&quot;.
	 * @return &quot;true&quot; if &quot;this&quot; is below &quot;other&quot; allowing for overlap, &quot;false&quot; otherwise.
	 */
	public boolean is_over_or_below(TemporalObject other) {
<span class="nc" id="L892">		return functions.overbelow_stbox_stbox(this._inner,this._get_box(other).get_inner());</span>
	}


	/**
	 * Returns whether &quot;this&quot; is strictly above &quot;other&quot;. Checks the Y dimension.
	 *
	 *&lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;above_stbox_stbox&lt;/li&gt;
	 * @param other The spatiotemporal object to compare with &quot;this&quot;.
	 * @return &quot;true&quot; if &quot;this&quot; is strictly above of &quot;other&quot;, &quot;false&quot; otherwise.
	 */
	public boolean is_above(TemporalObject other) {
<span class="nc" id="L906">		return functions.above_stbox_stbox(this._inner,this._get_box(other).get_inner());</span>
	}


	/**
	 * Returns whether &quot;this&quot; is above &quot;other&quot; allowing for overlap. That is, &quot;this&quot; does not extend
	 *         below &quot;other&quot;. Checks the Y dimension.
	 *
	 * &lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;overabove_stbox_stbox&lt;/li&gt;
	 * @param other The spatiotemporal object to compare with &quot;this&quot;.
	 * @return &quot;true&quot; if &quot;this&quot; is above &quot;other&quot; allowing for overlap, &quot;false&quot; otherwise.
	 */
	public boolean is_over_or_above(TemporalObject other) {
<span class="nc" id="L921">		return functions.overabove_stbox_stbox(this._inner,this._get_box(other).get_inner());</span>
	}


	/**
	 * Returns whether &quot;this&quot; is strictly in front of &quot;other&quot;. Checks the Z dimension.
	 *
	 * &lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;front_stbox_stbox&lt;/li&gt;
	 * @param other The spatiotemporal object to compare with &quot;this&quot;.
	 * @return &quot;true&quot; if &quot;this&quot; is strictly in front of &quot;other&quot;, &quot;false&quot; otherwise.
	 */
	public boolean is_front(TemporalObject other) {
<span class="nc" id="L935">		return functions.front_stbox_stbox(this._inner,this._get_box(other).get_inner());</span>
	}


	/**
	 * Returns whether &quot;this&quot; is in front of &quot;other&quot; allowing for overlap. That is, &quot;this&quot; does not extend
	 *         behind &quot;other&quot;. Checks the Z dimension.
	 *
	 * &lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;overfront_stbox_stbox&lt;/li&gt;
	 * @param other The spatiotemporal object to compare with &quot;this&quot;.
	 * @return &quot;true&quot; if &quot;this&quot; is in front of &quot;other&quot; allowing for overlap, &quot;false&quot; otherwise.
	 */
	public boolean is_over_or_front(TemporalObject other) {
<span class="nc" id="L950">		return functions.overfront_stbox_stbox(this._inner,this._get_box(other).get_inner());</span>
	}


	/**
	 * Returns whether &quot;this&quot; is strictly behind &quot;other&quot;. Checks the Z dimension.
	 *
	 * &lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;back_stbox_stbox&lt;/li&gt;
	 * @param other The spatiotemporal object to compare with &quot;this&quot;.
	 * @return &quot;true&quot; if &quot;this&quot; is strictly behind of &quot;other&quot;, &quot;false&quot; otherwise.
	 */
	public boolean is_behind(TemporalObject other) {
<span class="nc" id="L964">		return functions.back_stbox_stbox(this._inner,this._get_box(other).get_inner());</span>
	}


	/**
	 * Returns whether &quot;this&quot; is behind &quot;other&quot; allowing for overlap. That is, &quot;this&quot; does not extend
	 *         in front of &quot;other&quot;. Checks the Z dimension.
	 *
	 * &lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;overback_stbox_stbox&lt;/li&gt;
	 * @param other The spatiotemporal object to compare with &quot;this&quot;.
	 * @return &quot;true&quot; if &quot;this&quot; is behind of &quot;other&quot; allowing for overlap, &quot;false&quot; otherwise.
	 */
	public boolean is_over_or_behind(TemporalObject other) {
<span class="nc" id="L979">		return functions.overback_stbox_stbox(this._inner,this._get_box(other).get_inner());</span>
	}


	/**
	 *  Returns whether &quot;this&quot; is strictly before &quot;other&quot;. Checks the time dimension.
	 *
	 * &lt;p&gt;
	 *         See Also:
	 * 				{@link tstzset#is_before(TemporalObject)}
	 * 	&lt;p&gt;
	 * @param other The spatiotemporal object to compare with &quot;this&quot;.
	 * @return &quot;true&quot; if &quot;this&quot; is strictly before &quot;other&quot;, &quot;false&quot; otherwise.
	 */
	public boolean is_before(TemporalObject other) throws Exception {
<span class="nc" id="L994">		return this.to_tstzspan().is_before(other);</span>
	}


	/**
	 *  Returns whether &quot;this&quot; is before &quot;other&quot; allowing for overlap. That is, &quot;this&quot; does not extend
	 *         after &quot;other&quot;. Checks the time dimension.
	 *
	 * &lt;p&gt;
	 *     See Also:
	 * 	 			{@link tstzset#is_over_or_before(TemporalObject)}
	 * 	 &lt;/p&gt;
	 * @param other The spatiotemporal object to compare with &quot;this&quot;.
	 * @return &quot;true&quot; if &quot;this&quot; is before &quot;other&quot; allowing for overlap, &quot;false&quot; otherwise.
	 */
	public boolean is_over_or_before(TemporalObject other) throws Exception {
<span class="nc" id="L1010">		return this.to_tstzspan().is_over_or_before(other);</span>
	}


	/**
	 * Returns whether &quot;this&quot; is strictly after &quot;other&quot;. Checks the time dimension.
	 *
	 * &lt;p&gt;
	 *      See Also:
	 * 	 			{@link tstzset#is_after(TemporalObject)}
	 *     &lt;/p&gt;
	 * @param other The spatiotemporal object to compare with &quot;this&quot;.
	 * @return &quot;true&quot; if &quot;this&quot; is strictly after &quot;other&quot;, &quot;false&quot; otherwise.
	 */
	public boolean is_after(TemporalObject other) throws Exception {
<span class="nc" id="L1025">		return this.to_tstzspan().is_after(other);</span>
	}


	/**
	 * Returns whether &quot;this&quot; is after &quot;other&quot; allowing for overlap. That is, &quot;this does not extend
	 *         before &quot;other&quot;. Checks the time dimension.
	 *
	 *  &lt;p&gt;
	 *      See Also:
	 * 				{@link tstzset#is_over_or_after(TemporalObject)}
	 *      &lt;/p&gt;
	 * @param other The spatiotemporal object to compare with &quot;this&quot;.
	 * @return &quot;true&quot; if &quot;this&quot; is after &quot;other&quot; allowing for overlap, &quot;false&quot; otherwise.
	 */
	public boolean is_over_or_after(TemporalObject other) throws Exception {
<span class="nc" id="L1041">		return this.to_tstzspan().is_over_or_after(other);</span>
	}

    /* ------------------------- Distance Operations --------------------------- */


	/**
	 * Returns the distance between the nearest points of &quot;this&quot; and &quot;other&quot;.
	 *
	 * &lt;p&gt;
	 *
	 *         MEOS Functions:
	 *         &lt;ul&gt;
	 *             &lt;li&gt;nad_stbox_geo&lt;/li&gt;
	 *             &lt;li&gt;nad_stbox_stbox&lt;/li&gt;
	 *          &lt;/ul&gt;
	 * @param other The spatiotemporal object to compare with &quot;this&quot;.
	 * @return a Float instance with the distance between the nearest points of &quot;this&quot; and &quot;``other``&quot;.
	 */
	public float nearest_approach_distance_geom(Geometry other) {
<span class="nc" id="L1061">		return (float) functions.nad_stbox_geo(this._inner, ConversionUtils.geo_to_gserialized(other, this.geodetic()));</span>
	}


	/**
	 * Returns the distance between the nearest points of &quot;this&quot; and &quot;other&quot;.
	 *
	 * &lt;p&gt;
	 *
	 *         MEOS Functions:
	 *         &lt;ul&gt;
	 *             &lt;li&gt;nad_stbox_geo&lt;/li&gt;
	 *             &lt;li&gt;nad_stbox_stbox&lt;/li&gt;
	 *          &lt;/ul&gt;
	 * @param other The spatiotemporal object to compare with &quot;this&quot;.
	 * @return a Float instance with the distance between the nearest points of &quot;this&quot; and &quot;``other``&quot;.
	 */
	public float nearest_approach_distance_stbox(STBox other) {
<span class="nc" id="L1079">		return (float) functions.nad_stbox_stbox(this._inner, other._inner);</span>
	}


	/**
	 * Returns the distance between the nearest points of &quot;this&quot; and &quot;other&quot;.
	 *
	 * &lt;p&gt;
	 *
	 *         MEOS Functions:
	 *         &lt;ul&gt;
	 *             &lt;li&gt;nad_stbox_geo&lt;/li&gt;
	 *             &lt;li&gt;nad_stbox_stbox&lt;/li&gt;
	 *          &lt;/ul&gt;
	 * @param other The spatiotemporal object to compare with &quot;this&quot;.
	 * @return a Float instance with the distance between the nearest points of &quot;this&quot; and &quot;``other``&quot;.
	 */
	public float nearest_approach_distance_tpoint(TPoint other) {
<span class="nc" id="L1097">		return (float) functions.nad_tpoint_stbox(this._inner, other.getPointInner());</span>
	}



    /* ------------------------- Comparisons ----------------------------------- */

	/**
	 * Returns whether &quot;this&quot; is equal to &quot;other&quot;.
	 *
	 *  &lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;stbox_eq&lt;/li&gt;
	 * @param other The spatiotemporal object to compare with &quot;this&quot;.
	 * @return &quot;true&quot; if &quot;this&quot; is equal to &quot;other&quot;, &quot;false&quot; otherwise.
	 */
	public boolean eq(Box other) {
		boolean result;
<span class="pc bpc" id="L1115" title="2 of 4 branches missed.">		result = other instanceof STBox &amp;&amp; functions.stbox_eq(this._inner, ((STBox) other).get_inner());</span>
<span class="fc" id="L1116">		return result;</span>
	}


	/**
	 * Returns whether &quot;this&quot; is not equal to &quot;other&quot;.
	 *
	 *  &lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;stbox_ne&lt;/li&gt;
	 * @param other The spatiotemporal object to compare with &quot;this&quot;.
	 * @return &quot;true&quot; if &quot;this&quot; is not equal to &quot;other&quot;, &quot;false&quot; otherwise.
	 */
	public boolean notEquals(Box other) {
		boolean result;
<span class="nc bnc" id="L1131" title="All 4 branches missed.">		result = !(other instanceof STBox) || functions.stbox_ne(this._inner, ((STBox) other).get_inner());</span>
<span class="nc" id="L1132">		return result;</span>
	}

	/**
	 * Returns whether &quot;this&quot; is less than &quot;other&quot;. Compares first the SRID, then the time dimension,
	 *         and finally the spatial dimension (X, then Y then Z lower bounds and then the upper bounds).
	 *
	 * &lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;stbox_lt&lt;/li&gt;
	 * @param other The spatiotemporal object to compare with &quot;this&quot;.
	 * @return &quot;true&quot; if &quot;this&quot; is less than &quot;other&quot;, &quot;false&quot; otherwise.
	 */
	public boolean lessThan(Box other) throws OperationNotSupportedException {
<span class="nc bnc" id="L1146" title="All 2 branches missed.">		if (other instanceof STBox){</span>
<span class="nc" id="L1147">			return functions.stbox_lt(this._inner,((STBox) other).get_inner());</span>
		}
		else{
<span class="nc" id="L1150">			throw new OperationNotSupportedException(&quot;Operation not supported with this type.&quot;);</span>
		}
	}


	/**
	 * Returns whether &quot;this&quot; is less than or equal to &quot;other&quot;. Compares first the SRID, then the time dimension,
	 *         and finally the spatial dimension (X, then Y then Z lower bounds and then the upper bounds).
	 *
	 * &lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;stbox_le&lt;/li&gt;
	 * @param other The spatiotemporal object to compare with &quot;this&quot;.
	 * @return &quot;true&quot; if &quot;this&quot; is less than or equal &quot;other&quot;, &quot;false&quot; otherwise.
	 */
	public boolean lessThanOrEqual(Box other) throws OperationNotSupportedException {
<span class="nc bnc" id="L1166" title="All 2 branches missed.">		if (other instanceof STBox){</span>
<span class="nc" id="L1167">			return functions.stbox_le(this._inner,((STBox) other).get_inner());</span>
		}
		else{
<span class="nc" id="L1170">			throw new OperationNotSupportedException(&quot;Operation not supported with this type.&quot;);</span>
		}
	}


	/**
	 * Returns whether &quot;this&quot; is greater than &quot;other&quot;. Compares first the SRID, then the time dimension,
	 *         and finally the spatial dimension (X, then Y then Z lower bounds and then the upper bounds).
	 *
	 * &lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;stbox_gt&lt;/li&gt;
	 * @param other The spatiotemporal object to compare with &quot;this&quot;.
	 * @return &quot;true&quot; if &quot;this&quot; is greater &quot;other&quot;, &quot;false&quot; otherwise.
	 */
	public boolean greaterThan(Box other) throws OperationNotSupportedException {
<span class="nc bnc" id="L1186" title="All 2 branches missed.">		if (other instanceof STBox){</span>
<span class="nc" id="L1187">			return functions.stbox_gt(this._inner,((STBox) other).get_inner());</span>
		}
		else{
<span class="nc" id="L1190">			throw new OperationNotSupportedException(&quot;Operation not supported with this type.&quot;);</span>
		}
	}

	/**
	 *  Returns whether &quot;this&quot; is greater than or equal to &quot;other&quot;. Compares first the SRID, then the time dimension,
	 *         and finally the spatial dimension (X, then Y then Z lower bounds and then the upper bounds).
	 *
	 * &lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;stbox_ge&lt;/li&gt;
	 * @param other The spatiotemporal object to compare with &quot;this&quot;.
	 * @return &quot;true&quot; if &quot;this&quot; is greater or equal &quot;other&quot;, &quot;false&quot; otherwise.
	 */
	public boolean greaterThanOrEqual(Box other) throws OperationNotSupportedException {
<span class="nc bnc" id="L1205" title="All 2 branches missed.">		if (other instanceof STBox){</span>
<span class="nc" id="L1206">			return functions.stbox_ge(this._inner,((STBox) other).get_inner());</span>
		}
		else{
<span class="nc" id="L1209">			throw new OperationNotSupportedException(&quot;Operation not supported with this type.&quot;);</span>
		}
	}

	@Override
	public tstzspan to_period(){
<span class="fc" id="L1215">		error_handler_fn errorHandler = new error_handler();</span>
<span class="fc" id="L1216">		functions.meos_initialize(&quot;UTC&quot;, errorHandler);</span>
<span class="fc" id="L1217">		return new tstzspan(functions.stbox_to_tstzspan(this._inner));</span>
	}

	/* ------------------------- Splitting ----------------------------------- */
/**
        Returns a list of 4 (or 8 if `self`has Z dimension) :class:`STBox`
        instances resulting from the quad  split of ``self``.
&lt;p&gt;
        Indices of returned array are as follows (back only present if Z
        dimension is present):
&lt;p&gt;
           &gt;&gt;&gt; #    (front)          (back)&lt;br&gt;
           &gt;&gt;&gt; # -------------   -------------&lt;br&gt;
           &gt;&gt;&gt; # |  2  |  3  |   |  6  |  7  |&lt;br&gt;
           &gt;&gt;&gt; # ------------- + -------------&lt;br&gt;
           &gt;&gt;&gt; # |  0  |  1  |   |  4  |  5  |&lt;br&gt;
           &gt;&gt;&gt; # -------------   -------------&lt;br&gt;
&lt;p&gt;
        Returns:&lt;br&gt;
            A :class:`list` of :class:`STBox` instances.&lt;br&gt;
&lt;p&gt;
        MEOS Functions:&lt;br&gt;
            stbox_quad_split
*/
	public List&lt;STBox&gt; quad_split_flat(){
		// Create a JNR-FFI runtime instance
<span class="nc" id="L1243">		Runtime runtime = Runtime.getSystemRuntime();</span>
		// Allocate memory for an integer (4 bytes) but do not set a value
<span class="nc" id="L1245">		Pointer intPointer = Memory.allocate(Runtime.getRuntime(runtime), 4);</span>
<span class="nc" id="L1246">		Pointer resPointer= functions.stbox_quad_split(this.get_inner(), intPointer);</span>
<span class="nc" id="L1247">		int count= intPointer.getInt(Integer.BYTES);</span>
<span class="nc" id="L1248">		List&lt;STBox&gt; stBoxList= new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1249" title="All 2 branches missed.">		for(int i=0;i&lt;count;i++){</span>
<span class="nc" id="L1250">			Pointer p= resPointer.getPointer((long) i *Long.BYTES);</span>
<span class="nc" id="L1251">			STBox stbox= new STBox(p);</span>
<span class="nc" id="L1252">			stBoxList.add(stbox);</span>
		}
<span class="nc" id="L1254">		return stBoxList;</span>
	}

	/**
        Returns a 2D (YxX) or 3D (ZxYxX) list of :class:`STBox` instances
        resulting from the quad split of ``self``.&lt;p&gt;

        Indices of returned array are as follows:&lt;p&gt;

           &gt;&gt;&gt; #       (front)&lt;br&gt;
           &gt;&gt;&gt; # -------------------&lt;br&gt;
           &gt;&gt;&gt; # | [1][0] | [1][1] |&lt;br&gt;
           &gt;&gt;&gt; # -------------------&lt;br&gt;
           &gt;&gt;&gt; # | [0][0] | [0][1] |&lt;br&gt;
           &gt;&gt;&gt; # -------------------&lt;br&gt;
	    &lt;p&gt;
        If Z dimension is present:&lt;br&gt;

           &gt;&gt;&gt; #          (front)                      (back)&lt;br&gt;
           &gt;&gt;&gt; # -------------------------   -------------------------&lt;br&gt;
           &gt;&gt;&gt; # | [0][1][0] | [0][1][1] |   | [1][1][0] | [1][1][1] |&lt;br&gt;
           &gt;&gt;&gt; # ------------------------- + -------------------------&lt;br&gt;
           &gt;&gt;&gt; # | [0][0][0] | [0][0][1] |   | [1][0][0] | [1][0][1] |&lt;br&gt;
           &gt;&gt;&gt; # -------------------------   -------------------------&lt;br&gt;
	    &lt;p&gt;

        Returns:&lt;br&gt;
            A 2D or 3D :class:`list` of :class:`STBox` instances.
        &lt;p&gt;
        MEOS Functions:&lt;br&gt;
            stbox_quad_split

    */
	public List&lt;List&lt;List&lt;STBox&gt;&gt;&gt; quad_split() {
		// Create a JNR-FFI runtime instance
<span class="nc" id="L1289">		Runtime runtime = Runtime.getSystemRuntime();</span>
		// Allocate memory for an integer (4 bytes) but do not set a value
<span class="nc" id="L1291">		Pointer intPointer = Memory.allocate(Runtime.getRuntime(runtime), 4);</span>
<span class="nc" id="L1292">		Pointer resPointer= functions.stbox_quad_split(this.get_inner(), intPointer); // Populate boxes and count</span>
<span class="nc" id="L1293">		List&lt;STBox&gt; boxes= new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1294" title="All 2 branches missed.">		for(int i=0;i&lt;8;i++){</span>
<span class="nc" id="L1295">			STBox stBox= new STBox(resPointer.getPointer(i*Long.BYTES));</span>
<span class="nc" id="L1296">			boxes.add(stBox);</span>
		}

<span class="nc bnc" id="L1299" title="All 2 branches missed.">		if (this.has_z()) {</span>
			// 3D case (ZxYxX)
<span class="nc" id="L1301">			List&lt;List&lt;List&lt;STBox&gt;&gt;&gt; result = new ArrayList&lt;&gt;();</span>
			// Front part
<span class="nc" id="L1303">			List&lt;List&lt;STBox&gt;&gt; front = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1304">			front.add(List.of(boxes.get(0), boxes.get(1))); // [0][1][0], [0][1][1]</span>
<span class="nc" id="L1305">			front.add(List.of(boxes.get(2), boxes.get(3))); // [0][0][0], [0][0][1]</span>

			// Back part
<span class="nc" id="L1308">			List&lt;List&lt;STBox&gt;&gt; back = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1309">			back.add(List.of(boxes.get(4), boxes.get(5))); // [1][1][0], [1][1][1]</span>
<span class="nc" id="L1310">			back.add(List.of(boxes.get(6), boxes.get(7))); // [1][0][0], [1][0][1]</span>

<span class="nc" id="L1312">			result.add(front);</span>
<span class="nc" id="L1313">			result.add(back);</span>
<span class="nc" id="L1314">			return result;</span>
		} else {
			// 2D case (YxX)
<span class="nc" id="L1317">			List&lt;List&lt;STBox&gt;&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1318">			result.add(List.of(boxes.get(0), boxes.get(1))); // [1][0], [1][1]</span>
<span class="nc" id="L1319">			result.add(List.of(boxes.get(2), boxes.get(3))); // [0][0], [0][1]</span>
<span class="nc" id="L1320">			return List.of(result);</span>
		}
	}

	/**
        Returns a list of `STBox` instances representing the tiles of
        ``self``.

        Args:
            size: The size of the spatial tiles. If the `STBox` instance has a
                spatial dimension and this argument is not provided, the tiling
                will be only temporal.
            duration: The duration of the temporal tiles. If the `STBox`
                instance has a time dimension and this argument is not
                provided, the tiling will be only spatial.
            origin: The origin of the spatial tiling. If not provided, the
                origin will be (0, 0, 0).
            start: The start time of the temporal tiling. If not provided,
                the start time used by default is Monday, January 3, 2000.

        Returns:
            A list of `STBox` instances.

        MEOS Functions:
            stbox_tile_list
     */
//	public List&lt;STBox&gt; tile(double size, Object duration, Geometry origin, Object start){
//		double sz = Optional.of(size).orElse(
//                (double) (Math.max(Math.max(xmax() - xmin(), ymax() - ymin()), has_z() ? zmax() - zmin() : 0) + 1)
//        );
//
//		Pointer dt= null;
//		if(duration instanceof Duration){
//			dt= ConversionUtils.timedelta_to_interval((Duration) duration);
//		}
//		else{
//			if(duration instanceof String){
//				dt= functions.pg_interval_in(duration.toString(), -1);
//			}
//			else dt = null;
//		}
//
//		OffsetDateTime st= null;
//		if(start instanceof LocalDateTime){
//			st= ConversionUtils.datetimeToTimestampTz((LocalDateTime) start);
//		}
//		else{
//			if(start instanceof String){
//				st= functions.pg_timestamptz_in(start.toString(), -1);
//			}
//			else{
//				if(this.has_t()){
//					st= functions.pg_timestamptz_in(&quot;2000-01-03&quot;, -1);
//				}
//				else{
//					st= null;
//				}
//			}
//		}
//
//		Pointer gs= null;
//		if(origin!=null){
//			gs= ConversionUtils.geo_to_gserialized(origin, this.geodetic());
//		}
//		else{
//			if(this.geodetic()){
//				gs= functions.pgis_geography_in(&quot;Point(0 0 0)&quot;, -1);
//			}
//			else{
//				gs= functions.pgis_geometry_in(&quot;Point (0 0 0)&quot;, -1);
//			}
//		}
//
//		// Create a JNR-FFI runtime instance
//		Runtime runtime = Runtime.getSystemRuntime();
//		// Allocate memory for an integer (4 bytes) but do not set a value
//		Pointer intPointer = Memory.allocate(Runtime.getRuntime(runtime), 4);
//		Pointer resPointer= functions.stbox_space_time_tiles(this.get_inner(), sz, sz, sz, dt, gs, st);
//		int count= intPointer.getInt(Integer.BYTES);
//		List&lt;STBox&gt; stBoxes= new ArrayList&lt;&gt;();
//		for(int i=0;i&lt;count;i++){
//			Pointer p= resPointer.getPointer((long) i *Long.BYTES);
//			STBox s= new STBox(p);
//			stBoxes.add(s);
//		}
//		return stBoxes;
//	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>