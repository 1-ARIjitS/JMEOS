<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FunctionsGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jmeos</a> &gt; <a href="index.source.html" class="el_package">builder</a> &gt; <span class="el_source">FunctionsGenerator.java</span></div><h1>FunctionsGenerator.java</h1><pre class="source lang-java linenums">package builder;

import utils.BuilderUtils;
import utils.Pair;

import java.net.URI;
import java.net.URISyntaxException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Class used to generate the functions from the MEOS library.
 * Run with directly with java through the main class
 *
 * @author Killian Monnier and Nidhal Mareghni
 * @since 27/06/2023
 */
public class FunctionsGenerator {
	
	/**
	 * Path of the file generated by {@link FunctionsExtractor}. Contains a list of functions signature.
	 */
	private final Path C_functionsPath;
	
	/**
	 * Path of the file generated by {@link FunctionsExtractor}. Contains a list of types definition.
	 */
	@SuppressWarnings(&quot;FieldCanBeLocal&quot;)
	private final Path C_typesPath;
	
	/**
	 * Path of the file generated by this class.
	 */
	private final Path functionsFilePath;

	/**
	 * Types dictionary. Contains the C types and there equivalent in Java
	 */
<span class="nc" id="L42">	private final HashMap&lt;String, String&gt; equivalentTypes = buildEquivalentTypes();</span>
	

<span class="nc" id="L45">	private final HashMap&lt;String, String&gt; conversionTypes = buildConversionTypes();</span>
	

	private final HashMap&lt;String, String&gt; conversionTypedefs;


<span class="nc" id="L51">	private final ArrayList&lt;String&gt; unsupportedEquivalentTypes = new ArrayList&lt;&gt;(); // List of unsupported types</span>
<span class="nc" id="L52">	private final ArrayList&lt;String&gt; unsupportedConversionTypedefs = new ArrayList&lt;&gt;(); // List of unsupported types</span>
<span class="nc" id="L53">	private final ArrayList&lt;String&gt; unsupportedConversionTypes = new ArrayList&lt;&gt;(); // List of unsupported types</span>
	
	/**
	 * Constructor of {@link FunctionsExtractor}.
	 *
	 * @throws URISyntaxException thrown when resources not found
	 */
<span class="nc" id="L60">	public FunctionsGenerator() throws URISyntaxException {</span>
<span class="nc" id="L61">		this.C_functionsPath = Paths.get(Objects.requireNonNull(this.getClass().getResource(&quot;meos_functions.h&quot;)).toURI());</span>
<span class="nc" id="L62">		this.C_typesPath = Paths.get(Objects.requireNonNull(this.getClass().getResource(&quot;meos_types.h&quot;)).toURI());</span>
<span class="nc" id="L63">		this.functionsFilePath = Paths.get(new URI(Objects.requireNonNull(this.getClass().getResource(&quot;&quot;)) + &quot;functions.java&quot;));</span>
<span class="nc" id="L64">		this.conversionTypedefs = this.buildConversionTypedefs(this.C_typesPath.toString());</span>
<span class="nc" id="L65">	}</span>
	
	/**
	 * Gives the types of the function's parameters and return from a line corresponding to the format of a function.
	 *
	 * @param signature function signature
	 * @return types list
	 */
	private static ArrayList&lt;String&gt; getFunctionTypes(String signature) {
<span class="nc" id="L74">		ArrayList&lt;String&gt; functionTypes = BuilderUtils.extractFunctionTypes(signature);</span>
		
		/* Remove Array Types from the functionTypes list then change it to normal type */
<span class="nc" id="L77">		List&lt;String&gt; arrayTypesList = functionTypes.stream().filter(type -&gt; type.contains(&quot;[]&quot;)).toList();</span>
<span class="nc" id="L78">		functionTypes.removeAll(arrayTypesList);</span>
		
<span class="nc" id="L80">		List&lt;String&gt; newTypesList = arrayTypesList.stream().map(arrayType -&gt; arrayType.replace(&quot;[]&quot;, &quot;&quot;)).toList();</span>
<span class="nc" id="L81">		functionTypes.addAll(newTypesList);</span>
		
<span class="nc" id="L83">		return functionTypes;</span>
	}
	
	/**
	 * Launch process of extraction.
	 *
	 * @param args arguments
	 * @throws URISyntaxException thrown when resources not found
	 */
	public static void main(String[] args) throws URISyntaxException {
		
<span class="nc" id="L94">		var generator = new FunctionsGenerator();</span>
		
		/* Generation of all the functions signature */
<span class="nc" id="L97">		StringBuilder functionsInterfaceBuilder = generator.generateFunctions(generator.C_functionsPath.toString(), false);</span>
<span class="nc" id="L98">		StringBuilder functionsClassBuilder = generator.generateFunctions(generator.C_functionsPath.toString(), true);</span>
<span class="nc" id="L99">		System.out.println(&quot;Unsupported types: &quot; + generator.unsupportedEquivalentTypes);</span>
<span class="nc" id="L100">		System.out.println(&quot;Unsupported conversion typedefs: &quot; + generator.unsupportedConversionTypedefs);</span>
<span class="nc" id="L101">		System.out.println(&quot;Unsupported conversion types: &quot; + generator.unsupportedConversionTypes);</span>
		
		/* Generation of the file */
<span class="nc" id="L104">		StringBuilder interfaceBuilder = generator.generateInterface(functionsInterfaceBuilder);</span>
<span class="nc" id="L105">		StringBuilder classBuilder = generator.generateClass(functionsClassBuilder, interfaceBuilder);</span>
<span class="nc" id="L106">		BuilderUtils.writeFileFromBuilder(classBuilder, generator.functionsFilePath.toString());</span>
<span class="nc" id="L107">		String tmp_functionsFilePath = Paths.get(&quot;&quot;).toAbsolutePath() + &quot;/src/main/java/functions/functions.java&quot;;</span>
<span class="nc" id="L108">		BuilderUtils.writeFileFromBuilder(classBuilder, tmp_functionsFilePath);</span>
<span class="nc" id="L109">	}</span>
	
	/**
	 * Processes the rows to generate the functions.
	 *
	 * @param line the line corresponding to a function
	 * @return the processed line
	 */
	private static String performTypeConversion(String line) {
<span class="nc bnc" id="L118" title="All 2 branches missed.">		if (!line.isBlank()) {</span>
			/* Remove keywords that are not of interest to us */
<span class="nc" id="L120">			line = line.replaceAll(&quot;extern &quot;, &quot;&quot;);</span>
<span class="nc" id="L121">			line = line.replaceAll(&quot;const &quot;, &quot;&quot;);</span>
<span class="nc" id="L122">			line = line.replaceAll(&quot;static inline &quot;, &quot;&quot;);</span>
			
			/* Changing types with * */
<span class="nc" id="L125">			line = line.replaceAll(&quot;char\\s?\\*\\*&quot;, &quot;**char &quot;);</span>
<span class="nc" id="L126">			line = line.replaceAll(&quot;char\\s?\\*&quot;, &quot;*char &quot;);</span>
//			line = line.replaceAll(&quot;(\\w+\\s?\\*\\*\\*)(?!\\*)&quot;, &quot;*[][] &quot;);
//			line = line.replaceAll(&quot;(\\w+\\s?\\*\\*)(?!\\*)&quot;, &quot;*[] &quot;);
<span class="nc" id="L129">			line = line.replaceAll(&quot;\\w+\\s?(\\*+)&quot;, &quot;* &quot;);</span>
//			line = line.replaceAll(&quot;(\\w+\\s?\\*)(?!\\*)&quot;, &quot;* &quot;);
<span class="nc" id="L131">			line = line.replaceAll(&quot;\\s\\.\\.\\.&quot;, &quot; * args&quot;);</span>
			
			/* Changing special types or names */
<span class="nc" id="L134">			line = line.replaceAll(&quot;\\(void\\)&quot;, &quot;()&quot;); // Remove the void parameter (for the function meos_finish(void)) //</span>
<span class="nc" id="L135">			line = line.replaceAll(&quot;synchronized&quot;, &quot;synchronize&quot;); // Change the keyword used by Java (for the function temporal_simplify(const Temporal *temp, double eps_dist, bool synchronized))</span>
		}
		
<span class="nc" id="L138">		return line;</span>
	}
	
	/**
	 * Builds the type modification array.
	 * &lt;pre&gt;
	 * Key: old type in C or modified
	 * Value: new type in Java
	 * &lt;/pre&gt;
	 *
	 * @return type dictionary
	 */
	private static HashMap&lt;String, String&gt; buildEquivalentTypes() {
<span class="nc" id="L151">		HashMap&lt;String, String&gt; types = new HashMap&lt;&gt;();</span>
<span class="nc" id="L152">		types.put(&quot;\\*&quot;, &quot;Pointer&quot;);</span>
//		types.put(&quot;\\*\\[\\]&quot;, &quot;Pointer[]&quot;);
//		types.put(&quot;\\*\\[\\]\\[\\]&quot;, &quot;Pointer[][]&quot;);
//		types.put(&quot;\\*\\[]&quot;, &quot;Pointer[]&quot;);
//		types.put(&quot;\\*\\*\\[]&quot;, &quot;Pointer[][]&quot;);
<span class="nc" id="L157">		types.put(&quot;\\*char&quot;, &quot;String&quot;);</span>
<span class="nc" id="L158">		types.put(&quot;\\*\\*char&quot;, &quot;Pointer&quot;);</span>
<span class="nc" id="L159">		types.put(&quot;Pointer\\[\\]&quot;, &quot;Pointer&quot;); // Keep this line, otherwise operand error in JNR-FFI</span>
<span class="nc" id="L160">		types.put(&quot;bool&quot;, &quot;boolean&quot;);</span>
<span class="nc" id="L161">		types.put(&quot;float&quot;, &quot;float&quot;);</span>
<span class="nc" id="L162">		types.put(&quot;double&quot;, &quot;double&quot;);</span>
<span class="nc" id="L163">		types.put(&quot;void&quot;, &quot;void&quot;);</span>
<span class="nc" id="L164">		types.put(&quot;int&quot;, &quot;int&quot;);</span>
<span class="nc" id="L165">		types.put(&quot;short&quot;, &quot;short&quot;);</span>
<span class="nc" id="L166">		types.put(&quot;long&quot;, &quot;long&quot;);</span>
<span class="nc" id="L167">		types.put(&quot;int8&quot;, &quot;byte&quot;);</span>
<span class="nc" id="L168">		types.put(&quot;int16&quot;, &quot;short&quot;);</span>
<span class="nc" id="L169">		types.put(&quot;int32&quot;, &quot;int&quot;);</span>
<span class="nc" id="L170">		types.put(&quot;int64&quot;, &quot;long&quot;);</span>
<span class="nc" id="L171">		types.put(&quot;int8_t&quot;, &quot;byte&quot;);</span>
<span class="nc" id="L172">		types.put(&quot;int16_t&quot;, &quot;short&quot;);</span>
<span class="nc" id="L173">		types.put(&quot;int32_t&quot;, &quot;int&quot;);</span>
<span class="nc" id="L174">		types.put(&quot;int64_t&quot;, &quot;long&quot;);</span>
<span class="nc" id="L175">		types.put(&quot;uint8&quot;, &quot;byte&quot;);</span>
<span class="nc" id="L176">		types.put(&quot;uint16&quot;, &quot;short&quot;);</span>
<span class="nc" id="L177">		types.put(&quot;uint32&quot;, &quot;int&quot;);</span>
<span class="nc" id="L178">		types.put(&quot;uint64&quot;, &quot;long&quot;);</span>
<span class="nc" id="L179">		types.put(&quot;uint8_t&quot;, &quot;byte&quot;);</span>
<span class="nc" id="L180">		types.put(&quot;uint16_t&quot;, &quot;short&quot;);</span>
<span class="nc" id="L181">		types.put(&quot;uint32_t&quot;, &quot;int&quot;);</span>
<span class="nc" id="L182">		types.put(&quot;uint64_t&quot;, &quot;long&quot;);</span>
<span class="nc" id="L183">		types.put(&quot;uintptr_t&quot;, &quot;long&quot;);</span>
<span class="nc" id="L184">		types.put(&quot;size_t&quot;, &quot;long&quot;);</span>
<span class="nc" id="L185">		types.put(&quot;interpType&quot;, &quot;int&quot;); // enum in C</span>
		//types.put(&quot;\\char **&quot;,&quot;Pointer&quot;);
		
<span class="nc" id="L188">		return types;</span>
	}
	
	/**
	 * Build the dictionary of conversion types.
	 * &lt;pre&gt;
	 * Key: old type in C or modified
	 * Value: new type in Java
	 * &lt;/pre&gt;
	 *
	 * @return types dictionary
	 */
	private static HashMap&lt;String, String&gt; buildConversionTypes() {
<span class="nc" id="L201">		HashMap&lt;String, String&gt; conversionTypes = new HashMap&lt;&gt;();</span>
<span class="nc" id="L202">		conversionTypes.put(&quot;Timestamp&quot;, &quot;LocalDateTime&quot;);</span>
<span class="nc" id="L203">		conversionTypes.put(&quot;TimestampTz&quot;, &quot;OffsetDateTime&quot;);</span>
<span class="nc" id="L204">		return conversionTypes;</span>
	}
	
	/**
	 * Check unsupported types.
	 *
	 * @param signature function signature
	 */
	private static List&lt;String&gt; getUnsupportedTypes(String signature, Map&lt;String, String&gt; types) {
		/* Retrieving unsupported types for the line */
<span class="nc bnc" id="L214" title="All 2 branches missed.">		return getFunctionTypes(signature).stream().filter(type -&gt; !types.containsValue(type)).toList();</span>
	}
	
	/**
	 * Build the dictionary of typedef conversion.
	 * &lt;pre&gt;
	 * Key: old type in C or modified
	 * Value: new type in Java
	 * &lt;/pre&gt;
	 *
	 * @param filePath file path of C typedefs
	 * @return types dictionary
	 */
	private HashMap&lt;String, String&gt; buildConversionTypedefs(String filePath) {
<span class="nc" id="L228">		HashMap&lt;String, String&gt; typedefs = new HashMap&lt;&gt;();</span>
		
		/* Added typedefs extracted from C file */
<span class="nc" id="L231">		BuilderUtils.readFileLines(filePath, line -&gt; {</span>
<span class="nc" id="L232">			Pattern pattern = Pattern.compile(&quot;^typedef\\s(\\w+)\\s(\\w+);&quot;);</span>
<span class="nc" id="L233">			Matcher matcher = pattern.matcher(line);</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">			if (matcher.find()) {</span>
<span class="nc" id="L235">				String rawType = matcher.group(1);</span>
<span class="nc" id="L236">				String typeDef = matcher.group(2);</span>
				
<span class="nc" id="L238">				typedefs.put(typeDef, rawType);</span>
<span class="nc" id="L239">			} else {</span>
<span class="nc" id="L240">				System.err.println(&quot;Cannot extract type for row: &quot; + line);</span>
			}
<span class="nc" id="L242">		});</span>
<span class="nc" id="L243">		return typedefs;</span>
	}
	
	/**
	 * Produce the process of adding code to handle conversion of certain types for a function.
	 *
	 * @param signature function signature
	 * @return list of {@link Pair} defined as follows :
	 * &lt;ul&gt;
	 *     &lt;li&gt;Key : {@link Pair} defined as follows :&lt;/li&gt;
	 *     &lt;ul&gt;
	 *         &lt;li&gt;Key : old type name&lt;/li&gt;
	 *         &lt;li&gt;Value : new type name&lt;/li&gt;
	 *     &lt;/ul&gt;
	 *     &lt;li&gt;Value : list of lines for the conversion process&lt;/li&gt;
	 * &lt;/ul&gt;
	 */
	private List&lt;Pair&lt;Pair&lt;String, String&gt;, List&lt;String&gt;&gt;&gt; generateConversionProcess(String signature) {
<span class="nc" id="L261">		List&lt;Pair&lt;Pair&lt;String, String&gt;, List&lt;String&gt;&gt;&gt; conversionList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L262">		List&lt;Pair&lt;String, String&gt;&gt; typesList = BuilderUtils.extractParamTypesAndNames(signature);</span>
		
		/* For each types */
<span class="nc bnc" id="L265" title="All 2 branches missed.">		for (Pair&lt;String, String&gt; type : typesList) {</span>
<span class="nc" id="L266">			String typeValue = type.key();</span>
			
			/* If this type needs a conversion */
<span class="nc bnc" id="L269" title="All 2 branches missed.">			if (conversionTypes.containsValue(typeValue)) {</span>
<span class="nc" id="L270">				List&lt;String&gt; conversionLines = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L271">				String typeName = type.value();</span>
<span class="nc" id="L272">				String newTypeName = typeName + &quot;_new&quot;;</span>
				
<span class="nc bnc" id="L274" title="All 3 branches missed.">				switch (typeValue) {</span>
<span class="nc" id="L275">					case &quot;LocalDateTime&quot; -&gt; conversionLines.add(&quot;var &quot; + newTypeName + &quot; = &quot; + typeName + &quot;.toEpochSecond(ZoneOffset.UTC);&quot;);</span>
<span class="nc" id="L276">					case &quot;OffsetDateTime&quot; -&gt; conversionLines.add(&quot;var &quot; + newTypeName + &quot; = &quot; + typeName + &quot;.toEpochSecond();&quot;);</span>
<span class="nc" id="L277">					default -&gt; throw new TypeNotPresentException(typeValue, new Throwable(&quot;Type not supported by the builder conversion process&quot;));</span>
				}
<span class="nc" id="L279">				conversionList.add(new Pair&lt;&gt;(new Pair&lt;&gt;(typeName, newTypeName), conversionLines));</span>
			}
<span class="nc" id="L281">		}</span>
<span class="nc" id="L282">		return conversionList;</span>
	}

	/**
	 * utility function to count the number if occurences of pointer, pointer[] and pointer[][]
	 */
	public static int countOccurrences(String text, String pattern) {
<span class="nc" id="L289">		String[] parts = text.split(Pattern.quote(pattern), -1);</span>
<span class="nc" id="L290">		return parts.length - 1;</span>
	}
	
	/**
	 * Produce the returning process for a function
	 *
	 * @param signature      function signature
	 * @param typesNamesList list of types names to change it in the calling of the equivalent interface function
	 * @return the returning process
	 */
	private List&lt;String&gt; generateReturnProcess(String signature, List&lt;Pair&lt;String, String&gt;&gt; typesNamesList) {
<span class="nc" id="L301">		List&lt;String&gt; functionCallingProcess = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L302">		List&lt;String&gt; paramNames = BuilderUtils.extractParamNames(signature);</span>
		
		/* Manage the calling of meos library associate function */
<span class="nc bnc" id="L305" title="All 2 branches missed.">		if (!typesNamesList.isEmpty()) {</span>
			/* Modify the names of the parameter types that has endured conversion */
<span class="nc bnc" id="L307" title="All 2 branches missed.">			for (var typeNames : typesNamesList) {</span>
<span class="nc" id="L308">				String oldName = typeNames.key();</span>
<span class="nc" id="L309">				String newName = typeNames.value();</span>
<span class="nc" id="L310">				paramNames = BuilderUtils.modifyList(paramNames, oldName, newName);</span>
<span class="nc" id="L311">			}</span>
		}
<span class="nc bnc" id="L313" title="All 4 branches missed.">		if (! (paramNames.contains(&quot;result&quot;) || paramNames.contains(&quot;size_out&quot;))){</span>
<span class="nc" id="L314">			functionCallingProcess.add(&quot;MeosLibrary.meos.&quot; + BuilderUtils.extractFunctionName(signature) + &quot;(&quot; + BuilderUtils.getListWithoutBrackets(paramNames) + &quot;);&quot;);</span>
		}

		/* Manage the return process : if there is something to return */
<span class="nc bnc" id="L318" title="All 2 branches missed.">		if (!getFunctionTypes(signature).getFirst().equals(&quot;void&quot;)) {</span>
<span class="nc" id="L319">			var classReturnType = BuilderUtils.extractFunctionTypes(signature).getFirst();</span>
			
			/* Manage the returning process of conversion types */
<span class="nc bnc" id="L322" title="All 2 branches missed.">			if (conversionTypes.containsValue(classReturnType)) {</span>
<span class="nc" id="L323">				List&lt;String&gt; returnProcess = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L324">				var functionCall = BuilderUtils.removeSemicolon(functionCallingProcess.getFirst());</span>
				
<span class="nc" id="L326">				returnProcess.add(&quot;var result = &quot; + functionCall + &quot;;&quot;);</span>
				
<span class="nc bnc" id="L328" title="All 3 branches missed.">				switch (classReturnType) {</span>
<span class="nc" id="L329">					case &quot;LocalDateTime&quot; -&gt; returnProcess.add(</span>
							&quot;LocalDateTime.ofEpochSecond(result, 0, ZoneOffset.UTC);&quot;
					);
<span class="nc" id="L332">					case &quot;OffsetDateTime&quot; -&gt; returnProcess.addAll(List.of(</span>
							&quot;Instant instant = Instant.ofEpochSecond(result);&quot;,
							&quot;OffsetDateTime.ofInstant(instant, ZoneOffset.UTC);&quot;
					));
<span class="nc" id="L336">					default -&gt; throw new TypeNotPresentException(classReturnType, new Throwable(&quot;Type not supported by the builder returning conversion process&quot;));</span>
				}
<span class="nc" id="L338">				returnProcess.set(returnProcess.size() - 1, &quot;return &quot; + returnProcess.get(returnProcess.size() - 1)); // Add return at the last line of the list</span>
<span class="nc" id="L339">				functionCallingProcess = returnProcess;</span>
<span class="nc" id="L340">			} else {</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">				if (paramNames.contains(&quot;result&quot;)){</span>
<span class="nc" id="L342">					functionCallingProcess.add(&quot;boolean out;&quot;);</span>
<span class="nc" id="L343">					functionCallingProcess.add(&quot;Runtime runtime = Runtime.getSystemRuntime();&quot;);</span>
//					int pointer_total = signature.split(Pattern.quote(&quot;Pointer&quot;), -1).length -1;
//					int pointer_array_total = signature.split(Pattern.quote(&quot;Pointer[]&quot;), -1).length -1;

					// Count occurrences of &quot;Pointer&quot;
<span class="nc" id="L348">					int pointerCount = countOccurrences(signature, &quot;Pointer&quot;);</span>

					// Count occurrences of &quot;Pointer[]&quot;
<span class="nc" id="L351">					int pointerArrayCount = countOccurrences(signature, &quot;Pointer\\[\\]&quot;);</span>

					// Count occurrences of &quot;Pointer[][]&quot;
<span class="nc" id="L354">					int pointerArrayArrayCount = countOccurrences(signature, &quot;Pointer\\[\\]\\[\\]&quot;);</span>



<span class="nc bnc" id="L358" title="All 2 branches missed.">					if (pointerCount &gt; 1){</span>
<span class="nc" id="L359">						functionCallingProcess.add(&quot;Pointer result = Memory.allocateDirect(runtime, Long.BYTES);&quot;);</span>
<span class="nc" id="L360">						functionCallingProcess.add(&quot;out = MeosLibrary.meos.&quot; + BuilderUtils.extractFunctionName(signature) + &quot;(&quot; + BuilderUtils.getListWithoutBrackets(paramNames) + &quot;);&quot;);</span>
<span class="nc" id="L361">						functionCallingProcess.add(&quot;Pointer new_result = result.getPointer(0);&quot;);</span>
<span class="nc" id="L362">						functionCallingProcess.add(&quot;return out ? new_result : null ;&quot;);</span>
					}
<span class="nc bnc" id="L364" title="All 2 branches missed.">					else if (signature.contains(&quot;int &quot;)){</span>
<span class="nc" id="L365">						functionCallingProcess.add(&quot;Pointer result = Memory.allocateDirect(runtime, Integer.BYTES);&quot;);</span>
<span class="nc" id="L366">						functionCallingProcess.add(&quot;out = MeosLibrary.meos.&quot; + BuilderUtils.extractFunctionName(signature) + &quot;(&quot; + BuilderUtils.getListWithoutBrackets(paramNames) + &quot;);&quot;);</span>
<span class="nc" id="L367">						functionCallingProcess.add(&quot;return out ? result.getInt(0) : null ;&quot;);</span>
					}
<span class="nc bnc" id="L369" title="All 2 branches missed.">					else if (signature.contains(&quot;double &quot;)){</span>
<span class="nc" id="L370">						functionCallingProcess.add(&quot;Pointer result = Memory.allocateDirect(runtime, Double.BYTES);&quot;);</span>
<span class="nc" id="L371">						functionCallingProcess.add(&quot;out = MeosLibrary.meos.&quot; + BuilderUtils.extractFunctionName(signature) + &quot;(&quot; + BuilderUtils.getListWithoutBrackets(paramNames) + &quot;);&quot;);</span>
<span class="nc" id="L372">						functionCallingProcess.add(&quot;return out ? result.getDouble(0) : null ;&quot;);</span>
					}
<span class="nc bnc" id="L374" title="All 2 branches missed.">					else if (signature.contains(&quot;long &quot;)){</span>
<span class="nc" id="L375">						functionCallingProcess.add(&quot;Pointer result = Memory.allocateDirect(runtime, Long.BYTES);&quot;);</span>
<span class="nc" id="L376">						functionCallingProcess.add(&quot;out = MeosLibrary.meos.&quot; + BuilderUtils.extractFunctionName(signature) + &quot;(&quot; + BuilderUtils.getListWithoutBrackets(paramNames) + &quot;);&quot;);</span>
<span class="nc" id="L377">						functionCallingProcess.add(&quot;return out ? result.getLong(0) : null ;&quot;);</span>
					}
<span class="nc bnc" id="L379" title="All 2 branches missed.">					else if (signature.contains(&quot;boolean &quot;)){</span>
<span class="nc" id="L380">						functionCallingProcess.add(&quot;Pointer result = Memory.allocateDirect(runtime, Long.BYTES);&quot;);</span>
<span class="nc" id="L381">						functionCallingProcess.add(&quot;out = MeosLibrary.meos.&quot; + BuilderUtils.extractFunctionName(signature) + &quot;(&quot; + BuilderUtils.getListWithoutBrackets(paramNames) + &quot;);&quot;);</span>
<span class="nc" id="L382">						functionCallingProcess.add(&quot;return out ? true : false ;&quot;);</span>
					}

<span class="nc" id="L385">				}</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">				else if (paramNames.contains(&quot;size_out&quot;)){</span>
<span class="nc" id="L387">					functionCallingProcess.add(&quot;Runtime runtime = Runtime.getSystemRuntime();&quot;);</span>
<span class="nc" id="L388">					functionCallingProcess.add(&quot;Pointer size_out = Memory.allocateDirect(runtime, Long.BYTES);&quot;);</span>
<span class="nc" id="L389">					functionCallingProcess.add(&quot;return MeosLibrary.meos.&quot; + BuilderUtils.extractFunctionName(signature) + &quot;(&quot; + BuilderUtils.getListWithoutBrackets(paramNames) + &quot;);&quot;);</span>

				}
				else{
<span class="nc" id="L393">					functionCallingProcess.set(0, &quot;return &quot; + functionCallingProcess.getFirst());</span>
				}

			}
		}
<span class="nc" id="L398">		return functionCallingProcess;</span>
	}
	
	/**
	 * Used to generate the class of functions.
	 *
	 * @param functionsBuilder builder of functions
	 * @param interfaceBuilder interface builder
	 * @return the class builder
	 */
	private StringBuilder generateClass(StringBuilder functionsBuilder, StringBuilder interfaceBuilder) {
<span class="nc" id="L409">		var builder = new StringBuilder();</span>
		
<span class="nc" id="L411">		String imports_and_package = &quot;&quot;&quot;</span>
				package functions;
							
				import jnr.ffi.Pointer;
				import jnr.ffi.Memory;
				import jnr.ffi.Runtime;
				import jnr.ffi.byref.PointerByReference;
				import jnr.ffi.Struct;
				import utils.JarLibraryLoader;
				import utils.meosCatalog.MeosEnums.meosType;
				import utils.meosCatalog.MeosEnums.meosOper;
								
				import java.time.*;
				&quot;&quot;&quot;;
<span class="nc" id="L425">		String className = &quot;public class functions {&quot;;</span>
<span class="nc" id="L426">		builder.append(imports_and_package).append(&quot;\n&quot;).append(className).append(&quot;\n&quot;);</span>
		
		/* Added interface */
<span class="nc" id="L429">		BuilderUtils.appendStringBuilders(interfaceBuilder, builder, &quot;\t&quot;, &quot;\n\n&quot;);</span>
		
		/* Addition of functions */
<span class="nc" id="L432">		StringBuilder functionBodyBuilder = new StringBuilder();</span>
<span class="nc" id="L433">		BuilderUtils.readBuilderLines(functionsBuilder, line -&gt; {</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">			if (!line.isBlank()) {</span>
<span class="nc" id="L435">				String functionSignature = &quot;public static &quot; + BuilderUtils.removeSemicolon(line) + &quot; {\n&quot;;</span>
				/* Generate the conversion process */
<span class="nc" id="L437">				var conversionProcess = this.generateConversionProcess(line);</span>
<span class="nc" id="L438">				var conversionProcessList = BuilderUtils.extractPairValues(conversionProcess);</span>
<span class="nc" id="L439">				var conversionProcessContent = conversionProcessList.stream().flatMap(Collection::stream).toList();</span>
				
				/* Generate the returning process */
<span class="nc" id="L442">				var typesNamesList = BuilderUtils.extractPairKeys(conversionProcess);</span>
<span class="nc" id="L443">				var returnProcessContent = this.generateReturnProcess(line, typesNamesList);</span>

<span class="nc" id="L445">				String functionSignature2 =  &quot;public static &quot; + BuilderUtils.removeSemicolon(line) + &quot; {\n&quot;;</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">				if (functionSignature2.contains(&quot;result&quot;)){</span>
<span class="nc" id="L447">					int total = functionSignature2.split(Pattern.quote(&quot;Pointer&quot;), -1).length -1;</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">					if (total &gt; 1){</span>
<span class="nc" id="L449">						functionSignature2 = functionSignature2.replace(&quot;public static boolean&quot;,&quot;public static Pointer&quot;);</span>
					}
<span class="nc bnc" id="L451" title="All 2 branches missed.">					else if (functionSignature2.contains(&quot;int &quot;)){</span>
<span class="nc" id="L452">						functionSignature2 = functionSignature2.replace(&quot;public static boolean&quot;,&quot;public static int&quot;);</span>
					}
<span class="nc bnc" id="L454" title="All 2 branches missed.">					else if (functionSignature2.contains(&quot;double &quot;)){</span>
<span class="nc" id="L455">						functionSignature2 = functionSignature2.replace(&quot;public static boolean&quot;,&quot;public static double&quot;);</span>
					}
<span class="nc bnc" id="L457" title="All 2 branches missed.">					else if (functionSignature2.contains(&quot;long &quot;)){</span>
<span class="nc" id="L458">						functionSignature2 = functionSignature2.replace(&quot;public static boolean&quot;,&quot;public static long&quot;);</span>
					}
<span class="nc" id="L460">					functionSignature2 = functionSignature2.replace(&quot;, Pointer result&quot;,&quot;&quot;);</span>
<span class="nc" id="L461">				}</span>

<span class="nc bnc" id="L463" title="All 4 branches missed.">				else if (functionSignature2.contains(&quot;as_hexwkb&quot;) || functionSignature2.contains(&quot;as_wkb&quot;)){</span>
<span class="nc" id="L464">					functionSignature2 = functionSignature2.replace(&quot;, Pointer size_out&quot;,&quot;&quot;);</span>
				}
				/* Add all the different parts in the function body builder */
<span class="nc" id="L467">				functionBodyBuilder.append(&quot;@SuppressWarnings(\&quot;unused\&quot;)\n&quot;)</span>
<span class="nc" id="L468">						.append(functionSignature2)</span>
<span class="nc" id="L469">						.append(BuilderUtils.formattingLineList(conversionProcessContent, &quot;\t&quot;, &quot;\n&quot;))</span>
<span class="nc" id="L470">						.append(BuilderUtils.formattingLineList(returnProcessContent, &quot;\t&quot;, &quot;\n&quot;))</span>
<span class="nc" id="L471">						.append(BuilderUtils.formattingLine(&quot;}&quot;, &quot;&quot;, &quot;\n\n&quot;));</span>

			}
<span class="nc" id="L474">		});</span>
<span class="nc" id="L475">		BuilderUtils.appendStringBuilders(functionBodyBuilder, builder, &quot;\t&quot;, &quot;\n&quot;);</span>
<span class="nc" id="L476">		builder.append(&quot;}&quot;);</span>
<span class="nc" id="L477">		return builder;</span>
	}
	
	/**
	 * Generation of the interface.
	 *
	 * @param functionsBuilder builder of functions
	 * @return the interface builder
	 */
	private StringBuilder generateInterface(StringBuilder functionsBuilder) {
<span class="nc" id="L487">		var builder = new StringBuilder();</span>
		
<span class="nc" id="L489">		builder.append(&quot;&quot;&quot;</span>
				public interface MeosLibrary {
				    String libraryPath = &quot;libmeos.so&quot;;
					MeosLibrary INSTANCE = JarLibraryLoader.create(MeosLibrary.class, libraryPath).getLibraryInstance();
					MeosLibrary meos = MeosLibrary.INSTANCE;
				&quot;&quot;&quot;);
<span class="nc" id="L495">		BuilderUtils.appendStringBuilders(functionsBuilder, builder, &quot;\t&quot;, &quot;\n&quot;);</span>
<span class="nc" id="L496">		builder.append(&quot;}&quot;);</span>
<span class="nc" id="L497">		return builder;</span>
	}
	
	/**
	 * Generation of functions with their conversion types, typedef conversion types and equivalent types.
	 *
	 * @param filePath               file path of C functions
	 * @param performTypesConversion true if it needs to perform a types conversion using {@link FunctionsGenerator#conversionTypes}
	 * @return the function builder
	 */
	private StringBuilder generateFunctions(String filePath, boolean performTypesConversion) {
<span class="nc" id="L508">		var builder = new StringBuilder();</span>
		
<span class="nc" id="L510">		BuilderUtils.readFileLines(filePath, line -&gt; {</span>
<span class="nc" id="L511">			line = performTypeConversion(line);</span>
			
			/* Perform types conversion */
<span class="nc bnc" id="L514" title="All 2 branches missed.">			if (performTypesConversion) {</span>
<span class="nc" id="L515">				line = BuilderUtils.replaceTypes(conversionTypes, line);</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">				unsupportedConversionTypes.addAll(getUnsupportedTypes(line, conversionTypes).stream().filter(type -&gt; !unsupportedConversionTypes.contains(type)).toList());</span>
			}
			
			/* Perform typedef conversion */
<span class="nc" id="L520">			line = BuilderUtils.replaceTypes(conversionTypedefs, line);</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">			unsupportedConversionTypedefs.addAll(getUnsupportedTypes(line, conversionTypedefs).stream().filter(type -&gt; !unsupportedConversionTypedefs.contains(type)).toList());</span>
			
			/* Perform equivalent type conversion */
<span class="nc" id="L524">			line = BuilderUtils.replaceTypes(equivalentTypes, line);</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">			unsupportedEquivalentTypes.addAll(getUnsupportedTypes(line, equivalentTypes).stream().filter(type -&gt; !unsupportedEquivalentTypes.contains(type)).toList());</span>
			
<span class="nc" id="L527">			builder.append(BuilderUtils.formattingLine(line, &quot;&quot;, &quot;\n&quot;));</span>
<span class="nc" id="L528">		});</span>
<span class="nc" id="L529">		return builder;</span>
	}
	
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>