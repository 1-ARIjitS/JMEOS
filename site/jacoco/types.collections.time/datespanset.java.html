<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>datespanset.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jmeos</a> &gt; <a href="index.source.html" class="el_package">types.collections.time</a> &gt; <span class="el_source">datespanset.java</span></div><h1>datespanset.java</h1><pre class="source lang-java linenums">package types.collections.time;

import jnr.ffi.Pointer;
import org.locationtech.jts.io.ParseException;
import types.collections.base.*;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.time.Duration;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Objects;
import functions.functions;
import utils.ConversionUtils;

/**
    Class for representing lists of disjoint tstzspans.&lt;p&gt;

    :class:``DateSpanSet`` objects can be created with a single argument of type string
    as in MobilityDB.&lt;p&gt;

        &gt;&gt;&gt; DateSpanSet(string='{[2019-09-08, 2019-09-10], [2019-09-11, 2019-09-12]}')&lt;p&gt;

    Another possibility is to give a list specifying the composing&lt;br&gt;
    tstzspans, which can be instances  of :class:``str`` or :class:``DateSpan``.&lt;br&gt;
    The composing datespans must be given in increasing order.&lt;p&gt;

        &gt;&gt;&gt; DateSpanSet(span_list=['[2019-09-08, 2019-09-10]', '[2019-09-11, 2019-09-12]'])&lt;br&gt;
        &gt;&gt;&gt; DateSpanSet(span_list=[TsTzSpan('[2019-09-08, 2019-09-10]'), TsTzSpan('[2019-09-11, 2019-09-12]')])&lt;p&gt;
    @author ARIJIT SAMAL
*/

<span class="fc" id="L38">public class datespanset extends SpanSet&lt;LocalDate&gt; implements Time, TimeCollection{</span>

    private final Pointer _inner;

    public datespanset(Pointer inner){
<span class="fc" id="L43">        super(inner);</span>
<span class="fc" id="L44">        _inner = inner;</span>
<span class="fc" id="L45">    }</span>

    public datespanset(String str) {
<span class="fc" id="L48">        super(str);</span>
<span class="fc" id="L49">        _inner = functions.datespanset_in(str);</span>
<span class="fc" id="L50">    }</span>

<span class="fc" id="L52">    public datespanset(List&lt;?&gt; dspan) {</span>
<span class="fc" id="L53">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L54">        sb.append(&quot;{&quot;);</span>

<span class="pc bpc" id="L56" title="1 of 2 branches missed.">        if (dspan.isEmpty()) {</span>
<span class="nc" id="L57">            throw new IllegalArgumentException(&quot;List is empty&quot;);</span>
        }

<span class="fc bfc" id="L60" title="All 2 branches covered.">        if (dspan.getFirst() instanceof datespan) {</span>
<span class="fc bfc" id="L61" title="All 2 branches covered.">            for (int i = 0; i &lt; dspan.size(); i++) {</span>
<span class="fc" id="L62">                datespan ds = (datespan) dspan.get(i);</span>
<span class="pc bpc" id="L63" title="1 of 2 branches missed.">                if (ds == null) {</span>
<span class="nc" id="L64">                    throw new IllegalArgumentException(&quot;datespan list contains null element at index &quot; + i);</span>
                }
<span class="fc" id="L66">                sb.append(ds.toString());</span>
<span class="fc bfc" id="L67" title="All 2 branches covered.">                if (i &lt; dspan.size() - 1) {</span>
<span class="fc" id="L68">                    sb.append(&quot;, &quot;);</span>
                }
            }
<span class="pc bpc" id="L71" title="1 of 2 branches missed.">        } else if (dspan.getFirst() instanceof String) {</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">            for (int i = 0; i &lt; dspan.size(); i++) {</span>
<span class="fc" id="L73">                String ds = (String) dspan.get(i);</span>
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">                if (ds == null) {</span>
<span class="nc" id="L75">                    throw new IllegalArgumentException(&quot;String list contains null element at index &quot; + i);</span>
                }
<span class="fc" id="L77">                sb.append(ds);</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">                if (i &lt; dspan.size() - 1) {</span>
<span class="fc" id="L79">                    sb.append(&quot;, &quot;);</span>
                }
            }
        } else {
<span class="nc" id="L83">            throw new IllegalArgumentException(&quot;Unsupported list element type&quot;);</span>
        }

<span class="fc" id="L86">        sb.append(&quot;}&quot;);</span>
//        System.out.println(sb);
<span class="fc" id="L88">        _inner = functions.datespanset_in(sb.toString());</span>
<span class="fc" id="L89">    }</span>

/**
        Returns a :class:`DateSpanSet` set containing ``self``.

        Returns:
            A new :class:`DateSpanSet` instance

        MEOS Functions:
            span_to_spanset
*/

    public datespan to_span() throws InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException {
<span class="fc" id="L102">        return super.to_span(datespan.class);</span>
    }

/**
        Returns a :class:`TsTzSpan equivalent to ``self``.

        Returns:
            A new :class:`TsTzSpan` instance

        MEOS Functions:
            datespan_to_tstzspan
*/

    public tstzspanset to_tstzspanset() throws InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException {
<span class="fc" id="L116">        return new tstzspanset(functions.datespanset_to_tstzspanset(this._inner));</span>
    }

    /**
            Returns the duration of ``self``.

            Returns:
                A :class:`datetime.timedelta` instance representing the duration of
                the :class:`DateSpan`

            MEOS Functions:
                datespan_duration
    */
    public Duration duration(boolean ignore_gaps) throws InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException {
<span class="fc" id="L130">        return ConversionUtils.interval_to_timedelta(functions.datespanset_duration(this._inner, ignore_gaps));</span>
    }

    public int num_dates(){
<span class="fc" id="L134">        return functions.datespanset_num_dates(this._inner);</span>
    }

    @Override
    public Pointer createInner(Pointer inner) {
<span class="fc" id="L139">        return inner;</span>
    }

    @Override
    public Pointer createStringInner(String str) {
<span class="fc" id="L144">        return functions.datespanset_in(str);</span>
    }

    @Override
    public Pointer get_inner() {
<span class="fc" id="L149">        return this._inner;</span>
    }

    public LocalDate start_date(){
<span class="fc" id="L153">        return date_adt_to_date(functions.datespanset_start_date(this._inner));</span>
    }

    public LocalDate end_date(){
<span class="fc" id="L157">        return date_adt_to_date(functions.datespanset_end_date(this._inner));</span>
    }

/**
        Returns the n-th date in ``self``.
        Returns:
            A :class:`date` instance

        MEOS Functions:
*/

    public LocalDate date_n(int n) throws Exception {
<span class="nc bnc" id="L169" title="All 4 branches missed.">        if(n&lt;0 || n&gt;=this.num_dates()){</span>
<span class="nc" id="L170">            throw new Exception(&quot;Index out of bounds&quot;);</span>
        }
        else{
<span class="nc" id="L173">            Pointer resultPointer= functions.datespanset_date_n(this._inner, n+1);</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">            assert resultPointer != null;</span>
<span class="nc" id="L175">            int ts = resultPointer.getInt(0);</span>
<span class="nc" id="L176">            return date_adt_to_date(ts);</span>
        }
    }

    public String toString(){
<span class="fc" id="L181">        return functions.datespanset_out(this.get_inner());</span>
    }

/**
Function to convert the integer timestamp to LocalDate format so that it can be used by other libraries
*/

    public LocalDate date_adt_to_date(int ts){
<span class="fc" id="L189">        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);</span>
<span class="fc" id="L190">        String dateStr= functions.pg_date_out(ts);</span>
<span class="fc" id="L191">        return LocalDate.parse(dateStr, DateTimeFormatter.ISO_LOCAL_DATE);</span>
    }

    /**
            Returns the first date in ``self``.
            Returns:
                A :class:`date` instance

            MEOS Functions:
                dateset_start_value
    */

    public datespan start_span() throws ParseException {
<span class="fc" id="L204">        return new datespan(functions.spanset_start_span(this._inner));</span>
    }

/**
        Returns the last date in ``self``.
        Returns:
            A :class:`date` instance

        MEOS Functions:
            dateset_end_value
*/

    public datespan end_element() throws ParseException {
<span class="fc" id="L217">        return new datespan(functions.spanset_end_span(this._inner));</span>
    }

    public datespan span_n(int n) throws ParseException {
<span class="fc" id="L221">        return new datespan(functions.spanset_span_n(this._inner, n));</span>
    }

    public List&lt;datespan&gt; elements() throws Exception {
<span class="fc" id="L225">        return super.spans(datespan.class);</span>
//        Pointer ps = functions.spanset_spans(this._inner);
//        int numSpans = this.num_spans();
//        System.out.println(numSpans);
//        List&lt;datespan&gt; spanList = new ArrayList&lt;datespan&gt;();
//        long pointerSize = Long.BYTES;
//
//        for (long i = 0; i &lt; numSpans; i++) {
//            Pointer p = ps.getPointer(i * pointerSize);
//            datespan ds = new datespan(p);
//            spanList.add(ds);
//        }
//        System.out.println(spanList);
//        return spanList;
    }


/**
        Returns a new :class:`DateSpan` that starts as ``self`` but has
        duration ``duration``.

        Examples:
            &gt;&gt;&gt; DateSpan('[2000-01-01, 2000-01-10]').scale(timedelta(days=2))
            &gt;&gt;&gt; 'DateSpan([2000-01-01, 2000-01-03])'

        Args:
            duration: :class:`datetime.timedelta` instance representing the
            duration of the new dateSpan

        Returns:
            A new :class:`DateSpan` instance

        MEOS Functions:
            datespan_shift_scale
*/

    public datespan scale(int duration){
<span class="nc" id="L262">        return new datespan(this.shift_scale(0, duration).get_inner());</span>
    }

/**
        Returns a new :class:`DateSpan` that is the result of shifting ``self`` by
        ``delta``.

        Examples:
            &gt;&gt;&gt; DateSpan('[2000-01-01, 2000-01-10]').shift(timedelta(days=2))
            &gt;&gt;&gt; 'DateSpan([2000-01-03, 2000-01-12])'

        Args:
            delta: :class:`datetime.timedelta` instance to shift

        Returns:
            A new :class:`DateSpan` instance

        MEOS Functions:
            datespan_shift_scale
*/

    public datespanset shift(int shift){
<span class="fc" id="L284">        return new datespanset(this.shift_scale(shift, 0).get_inner());</span>
    }

/**
        Returns a new :class:`DateSpan` that starts at ``self`` shifted by ``shift`` and
        has duration ``duration``

        Examples:
            &gt;&gt;&gt; DateSpan('[2000-01-01, 2000-01-10]').shift_scale(shift=timedelta(days=2), duration=timedelta(days=4))
            &gt;&gt;&gt; 'DateSpan([2000-01-03, 2000-01-07])'

        Args:
            shift: :class:`datetime.timedelta` instance to shift
            duration: :class:`datetime.timedelta` instance representing the
            duration of the new dateSpan

        Returns:
            A new :class:`DateSpan` instance

        MEOS Functions:
            datespan_shift_scale
*/

    public datespanset shift_scale(Integer shift, Integer duration){
<span class="pc bpc" id="L308" title="1 of 4 branches missed.">        return new datespanset(functions.datespanset_shift_scale(this._inner, shift, duration, shift!=0, duration!=0));</span>
    }

    /**
            Returns whether ``self`` temporally contains ``content``.

            Examples:
                &gt;&gt;&gt; DateSpan('[2012-01-01, 2012-01-04]').contains(DateSpan('[2012-01-02, 2012-01-03]'))
                &gt;&gt;&gt; True
                &gt;&gt;&gt; DateSpan('[2012-01-01, 2012-01-02]').contains(DateSpan('(2012-01-01, 2012-01-02)'))
                &gt;&gt;&gt; True
                &gt;&gt;&gt; DateSpan('(2012-01-01, 2012-01-02)').contains(DateSpan('[2012-01-01, 2012-01-02]'))
                &gt;&gt;&gt; False

            Args:
                content: temporal object to compare with

            Returns:
                True if contains, False otherwise

            MEOS Functions:
                contains_span_span, contains_span_spanset, contains_span_date
    */
    public int dateToTimestamp(LocalDate date){
<span class="fc" id="L332">        return functions.pg_date_in(date.toString());</span>
    }

    public boolean contains(Object other) throws Exception {
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">        if (other instanceof LocalDate){</span>
<span class="fc" id="L337">            return functions.contains_spanset_date(this._inner, dateToTimestamp((LocalDate) other));</span>
        }
        else {
<span class="nc" id="L340">            return super.contains((Base) other);</span>
        }
    }

/**
        Returns whether ``self`` is adjacent to ``other``. That is, they share
        a bound but only one of them contains it.

        Args:
            other: object to compare with

        Returns:
            True if adjacent, False otherwise

        MEOS Functions:
            adjacent_span_span, adjacent_span_spanset, adjacent_span_date
*/

    public boolean is_adjacent(Object other) throws Exception {
<span class="pc bpc" id="L359" title="1 of 2 branches missed.">        if (other instanceof LocalDate){</span>
<span class="fc" id="L360">            return functions.adjacent_spanset_date(this._inner, dateToTimestamp((LocalDate) other));</span>
        }
        else{
<span class="nc" id="L363">            return super.is_adjacent((Base) other);</span>
        }
    }


/**
        Returns whether ``self`` temporally overlaps ``other``. That is, both
        share at least an instant

        Examples:
            &gt;&gt;&gt; DateSpan('[2012-01-01, 2012-01-02]').overlaps(DateSpan('[2012-01-02, 2012-01-03]'))
            &gt;&gt;&gt; True
            &gt;&gt;&gt; DateSpan('[2012-01-01, 2012-01-02)').overlaps(DateSpan('[2012-01-02, 2012-01-03]'))
            &gt;&gt;&gt; False
            &gt;&gt;&gt; DateSpan('[2012-01-01, 2012-01-02)').overlaps(DateSpan('(2012-01-02, 2012-01-03]'))
            &gt;&gt;&gt; False

        Args:
            other: temporal object to compare with

        Returns:
            True if overlaps, False otherwise

        MEOS Functions:
            overlaps_span_span, overlaps_span_spanset
*/

    public boolean overlaps(Object other) throws Exception {
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">        if (other instanceof LocalDate){</span>
<span class="fc" id="L392">            return this.contains(other);</span>
        }
        else {
<span class="nc" id="L395">            return super.overlaps((Base) other);</span>
        }
    }

/**
        Returns whether ``self`` is strictly before ``other``. That is,
        ``self`` ends before ``other`` starts.

        Examples:
            &gt;&gt;&gt; DateSpan('[2012-01-01, 2012-01-02)').is_left(DateSpan('[2012-01-02, 2012-01-03]'))
            &gt;&gt;&gt; True
            &gt;&gt;&gt; DateSpan('[2012-01-01, 2012-01-02)').is_left(DateSpan('(2012-01-02, 2012-01-03]'))
            &gt;&gt;&gt; True
            &gt;&gt;&gt; DateSpan('[2012-01-01, 2012-01-02]').is_left(DateSpan('[2012-01-02, 2012-01-03]'))
            &gt;&gt;&gt; False

        Args:
            other: temporal object to compare with

        Returns:
            True if before, False otherwise

        MEOS Functions:
            left_span_span, left_span_spanset, before_span_date,
*/

    public boolean is_left(Object other) throws Exception {
<span class="nc bnc" id="L422" title="All 2 branches missed.">        if (other instanceof LocalDate){</span>
<span class="nc" id="L423">            return functions.before_spanset_date(this._inner, dateToTimestamp(((LocalDate) other)));</span>
        }
        else {
<span class="nc" id="L426">            return super.is_left((Base) other);</span>
        }
    }

/**
        Returns whether ``self`` is before ``other`` allowing overlap. That is,
        ``self`` ends before ``other`` ends (or at the same time).

        Examples:
            &gt;&gt;&gt; DateSpan('[2012-01-01, 2012-01-02)').is_over_or_left(DateSpan('[2012-01-02, 2012-01-03]'))
            &gt;&gt;&gt; True
            &gt;&gt;&gt; DateSpan('[2012-01-01, 2012-01-02]').is_over_or_left(DateSpan('[2012-01-02, 2012-01-03]'))
            &gt;&gt;&gt; True
            &gt;&gt;&gt; DateSpan('[2012-01-03, 2012-01-05]').is_over_or_left(DateSpan('[2012-01-01, 2012-01-04]'))
            &gt;&gt;&gt; False

        Args:
            other: temporal object to compare with

        Returns:
            True if before, False otherwise

        MEOS Functions:
            overleft_span_span, overleft_span_spanset, overbefore_span_date,
*/

    public boolean is_over_or_left(Object other) throws Exception {
<span class="nc bnc" id="L453" title="All 2 branches missed.">        if (other instanceof LocalDate){</span>
<span class="nc" id="L454">            return functions.overbefore_spanset_date(this._inner, dateToTimestamp(((LocalDate) other)));</span>
        }
        else {
<span class="nc" id="L457">            return super.is_over_or_left((Base) other);</span>
        }
    }

/**
        Returns whether ``self`` is after ``other`` allowing overlap. That is,
        ``self`` starts after ``other`` starts (or at the same time).

        Examples:
            &gt;&gt;&gt; DateSet('{2012-01-02, 2012-01-03}').is_over_or_right(DateSpan('[2012-01-01, 2012-01-02)'))
            &gt;&gt;&gt; True
            &gt;&gt;&gt; DateSet('{2012-01-02, 2012-01-03}').is_over_or_right(DateSpan('[2012-01-01, 2012-01-02]'))
            &gt;&gt;&gt; True
            &gt;&gt;&gt; DateSet('{2012-01-02, 2012-01-03}').is_over_or_right(DateSpan('[2012-01-01, 2012-01-03]'))
            &gt;&gt;&gt; False

        Args:
            other: temporal object to compare with

        Returns:
            True if overlapping or after, False otherwise

        MEOS Functions:
            overafter_set_date, overright_span_span, overright_span_spanset
*/

    public boolean is_over_or_right(Object other) throws Exception {
<span class="nc bnc" id="L484" title="All 2 branches missed.">        if (other instanceof LocalDate){</span>
<span class="nc" id="L485">            return functions.overafter_spanset_date(this._inner, dateToTimestamp(((LocalDate) other)));</span>
        }
        else {
<span class="nc" id="L488">            return super.is_over_or_right((Base) other);</span>
        }
    }


/**
        Returns whether ``self`` is strictly after ``other``. That is, ``self``
        starts after ``other`` ends.

        Examples:
            &gt;&gt;&gt; DateSpan('[2012-01-02, 2012-01-03]').is_right(DateSpan('[2012-01-01, 2012-01-02)'))
            &gt;&gt;&gt; True
            &gt;&gt;&gt; DateSpan('(2012-01-02, 2012-01-03]').is_right(DateSpan('[2012-01-01, 2012-01-02)'))
            &gt;&gt;&gt; True
            &gt;&gt;&gt; DateSpan('[2012-01-02, 2012-01-03]').is_right(DateSpan('[2012-01-01, 2012-01-02]'))
            &gt;&gt;&gt; False

        Args:
            other: temporal object to compare with

        Returns:
            True if after, False otherwise

        MEOS Functions:
            right_span_span, right_span_spanset, after_span_date,
*/

    public boolean is_right(Object other) throws Exception {
<span class="nc bnc" id="L516" title="All 2 branches missed.">        if (other instanceof LocalDate){</span>
<span class="nc" id="L517">            return functions.after_spanset_date(this._inner, dateToTimestamp(((LocalDate) other)));</span>
        }
        else {
<span class="nc" id="L520">            return super.is_right((Base) other);</span>
        }
    }

    @Override
    public boolean is_before(Object other) throws Exception {
<span class="fc" id="L526">        return TimeCollection.super.is_before(other);</span>
    }

    @Override
    public boolean is_over_or_before(Object other) throws Exception {
<span class="fc" id="L531">        return TimeCollection.super.is_over_or_before(other);</span>
    }

    @Override
    public boolean is_over_or_after(Object other) throws Exception {
<span class="fc" id="L536">        return TimeCollection.super.is_over_or_after(other);</span>
    }

    @Override
    public boolean is_after(Object other) throws Exception {
<span class="fc" id="L541">        return TimeCollection.super.is_after(other);</span>
    }

    /*---------------Distance Operations-------------------*/


/**
        Returns the temporal distance between ``self`` and ``other``.

        Args:
            other: temporal object to compare with

        Returns:
            A :class:`datetime.timedelta` instance

        MEOS Functions:
            distance_set_date, distance_dateset_dateset,
            distance_datespanset_datespan, distance_datespanset_datespanset
*/

    public Duration distance(Object other) throws Exception {
<span class="fc" id="L562">        Duration answer = null;</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">        if (other instanceof LocalDate) {</span>
<span class="fc" id="L564">            answer= Duration.ofSeconds(functions.distance_spanset_date(this._inner, dateToTimestamp((LocalDate) other)));</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">        } else if (other instanceof dateset) {</span>
<span class="fc" id="L566">            datespanset ds = ((dateset) other).to_spanset(datespanset.class);</span>
<span class="fc" id="L567">            answer= Duration.ofSeconds(functions.distance_datespanset_datespanset(this._inner, (ds).get_inner()));</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">        } else if (other instanceof datespan) {</span>
<span class="fc" id="L569">            answer= Duration.ofSeconds(functions.distance_datespanset_datespan(this._inner, ((datespan) other).get_inner()));</span>
<span class="pc bpc" id="L570" title="1 of 2 branches missed.">        } else if (other instanceof datespanset) {</span>
<span class="fc" id="L571">            answer= Duration.ofSeconds(functions.distance_datespanset_datespanset(this._inner, ((datespanset) other).get_inner()));</span>
        } else {
<span class="nc" id="L573">            throw new Exception(&quot;Operation not supported with&quot;+other+&quot;type&quot;);</span>
        }
<span class="fc" id="L575">        return answer;</span>
    }


    /*---------------Set Operations-------------------*/

    /**
     *
     * Convert timestamp (number of seconds since epoch) to LocalDateTime
     */

    public static LocalDateTime timestampToLocalDateTime(int timestamp) {
<span class="nc" id="L587">        return LocalDateTime.ofEpochSecond(timestamp, 0, ZoneOffset.UTC);</span>
    }

/**
        Returns the temporal intersection of ``self`` and ``other``.

        Args:
            other: temporal object to intersect with

        Returns:
            A :class:`TimeDate` instance. The actual class depends on ``other``.

        MEOS Functions:
            intersection_set_date, intersection_set_set, intersection_spanset_span,
            intersection_spanset_spanset
*/

    public datespanset intersection(Object other) throws Exception {
<span class="fc" id="L605">        datespanset result = null;</span>
<span class="fc bfc" id="L606" title="All 2 branches covered.">        if (other instanceof LocalDate){</span>
<span class="fc" id="L607">            Pointer resultPointer= functions.intersection_spanset_date(this._inner, dateToTimestamp((LocalDate) other));</span>
<span class="fc" id="L608">            result = new datespanset(resultPointer);</span>
<span class="fc" id="L609">        }</span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">        else if (other instanceof datespan){</span>
<span class="fc" id="L611">            Pointer resultPointer= functions.intersection_spanset_span(this._inner, ((datespan) other).get_inner());</span>
<span class="fc" id="L612">            result = new datespanset(resultPointer);</span>
<span class="fc" id="L613">        }</span>
<span class="fc bfc" id="L614" title="All 2 branches covered.">        else if (other instanceof dateset){</span>
<span class="fc" id="L615">            datespanset ds = ((dateset) other).to_spanset(datespanset.class);</span>
<span class="fc" id="L616">            Pointer resultPointer= functions.intersection_spanset_spanset(this._inner, (ds).get_inner());</span>
<span class="fc" id="L617">            result = new datespanset(resultPointer);</span>
<span class="fc" id="L618">        }</span>
<span class="pc bpc" id="L619" title="1 of 2 branches missed.">        else if (other instanceof datespanset){</span>
<span class="fc" id="L620">            Pointer resultPointer= functions.intersection_spanset_spanset(this._inner, ((datespanset) other).get_inner());</span>
<span class="fc" id="L621">            result = new datespanset(resultPointer);</span>
<span class="fc" id="L622">        }</span>
        else{
<span class="nc" id="L624">            throw new Exception(&quot;Operation not supported with this type&quot;);</span>
        }
<span class="fc" id="L626">        return result;</span>
    }

/**
        Returns the temporal difference of ``self`` and ``other``.

        Args:
            other: temporal object to diff with

        Returns:
            A :class:`DateSpanSet` instance.

        MEOS Functions:
            minus_span_date, minus_span_spanset, minus_span_span
*/

    public datespanset minus(Object other) throws Exception{
<span class="fc" id="L643">        datespanset result = null;</span>
<span class="fc bfc" id="L644" title="All 2 branches covered.">        if (other instanceof LocalDate){</span>
<span class="fc" id="L645">            Pointer resultPointer= functions.minus_spanset_date(this._inner, dateToTimestamp((LocalDate) other));</span>
<span class="fc" id="L646">            result= new datespanset(resultPointer);</span>
<span class="fc" id="L647">        }</span>
<span class="fc bfc" id="L648" title="All 2 branches covered.">        else if (other instanceof datespan){</span>
<span class="fc" id="L649">            Pointer resultPointer= functions.minus_spanset_span(this._inner, ((datespan) other).get_inner());</span>
<span class="fc" id="L650">            result = new datespanset(resultPointer);</span>
<span class="fc" id="L651">        }</span>
<span class="fc bfc" id="L652" title="All 2 branches covered.">        else if (other instanceof dateset){</span>
<span class="fc" id="L653">            datespanset ds = ((dateset) other).to_spanset(datespanset.class);</span>
<span class="fc" id="L654">            Pointer resultPointer= functions.minus_spanset_spanset(this._inner, (ds).get_inner());</span>
<span class="fc" id="L655">            result = new datespanset(resultPointer);</span>
<span class="fc" id="L656">        }</span>
<span class="pc bpc" id="L657" title="1 of 2 branches missed.">        else if (other instanceof datespanset){</span>
<span class="fc" id="L658">            Pointer resultPointer= functions.minus_spanset_spanset(this._inner, ((datespanset) other).get_inner());</span>
<span class="fc" id="L659">            result = new datespanset(resultPointer);</span>
<span class="fc" id="L660">        }</span>
        else{
<span class="nc" id="L662">            throw new Exception(&quot;Operation not supported with this type&quot;);</span>
        }
<span class="fc" id="L664">        return result;</span>
    }

    /**
     *
     * convert timestamp (number of seconds since epoch) to LocalDate
     */

    public static LocalDate timestampToLocalDate(int timestamp) {
<span class="nc" id="L673">        return LocalDate.ofEpochDay(timestamp / 86400); // Convert seconds back to days</span>
    }

    public LocalDate subtract_from(Object other) throws Exception {
<span class="nc" id="L677">        int ts= dateToTimestamp((LocalDate) other);</span>
<span class="nc" id="L678">        Pointer resultPointer= functions.minus_date_set(ts, this._inner);</span>
<span class="nc" id="L679">        int resultTimestamp= resultPointer.getInt(Integer.BYTES);</span>
<span class="nc" id="L680">        return timestampToLocalDate(resultTimestamp);</span>
    }

/**
        Returns the temporal union of ``self`` and ``other``.

        Args:
            other: temporal object to merge with

        Returns:
            A :class:`DateSpanSet` instance.

        MEOS Functions:
            union_span_date, union_spanset_span, union_span_span
*/

    public datespanset union(Object other) throws Exception{
<span class="fc" id="L697">        datespanset result = null;</span>
<span class="fc bfc" id="L698" title="All 2 branches covered.">        if (other instanceof LocalDate){</span>
<span class="fc" id="L699">            Pointer resultPointer= functions.union_spanset_date(this._inner, dateToTimestamp((LocalDate) other));</span>
<span class="fc" id="L700">            result = new datespanset(resultPointer);</span>
<span class="fc" id="L701">        }</span>
<span class="fc bfc" id="L702" title="All 2 branches covered.">        else if (other instanceof datespan){</span>
<span class="fc" id="L703">            Pointer resultPointer= functions.union_spanset_span(this._inner, ((datespan) other).get_inner());</span>
<span class="fc" id="L704">            result = new datespanset(resultPointer);</span>
<span class="fc" id="L705">        }</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">        else if (other instanceof dateset){</span>
<span class="fc" id="L707">            datespanset ds = ((dateset) other).to_spanset(datespanset.class);</span>
<span class="fc" id="L708">            Pointer resultPointer= functions.union_spanset_spanset(this._inner, (ds).get_inner());</span>
<span class="fc" id="L709">            result = new datespanset(resultPointer);</span>
<span class="fc" id="L710">        }</span>
<span class="pc bpc" id="L711" title="1 of 2 branches missed.">        else if (other instanceof datespanset){</span>
<span class="fc" id="L712">            Pointer resultPointer= functions.union_spanset_spanset(this._inner, ((datespanset) other).get_inner());</span>
<span class="fc" id="L713">            result = new datespanset(resultPointer);</span>
<span class="fc" id="L714">        }</span>
        else{
<span class="nc" id="L716">            throw new Exception(&quot;Operation not supported with this type&quot;);</span>
        }
<span class="fc" id="L718">        return result;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>