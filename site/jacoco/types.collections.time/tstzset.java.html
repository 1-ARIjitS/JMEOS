<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>tstzset.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jmeos</a> &gt; <a href="index.source.html" class="el_package">types.collections.time</a> &gt; <span class="el_source">tstzset.java</span></div><h1>tstzset.java</h1><pre class="source lang-java linenums">package types.collections.time;

import jnr.ffi.Pointer;
import types.TemporalObject;
import types.boxes.Box;
import types.collections.base.Base;
import types.collections.base.Set;

import java.time.Duration;
import java.time.LocalDateTime;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import functions.functions;
import java.util.List;
import java.util.Objects;

//import types.boxes.*;

//import types.temporal.Temporal;
import types.collections.base.Span;
import types.collections.base.SpanSet;
import types.temporal.Temporal;
import utils.ConversionUtils;


/**
 * Class for representing lists of distinct timestamp values.
 *	&lt;pre&gt;
 *     ``tstzset`` objects can be created with a single argument of type string
 *     as in MobilityDB.
 *
 *         &gt;&gt;&gt; tstzset(string='{2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01, 2019-09-11 00:00:00+01}')
 *
 *     Another possibility is to give a tuple or list of composing timestamps,
 *     which can be instances of ``str`` or ``datetime``. The composing timestamps
 *     must be given in increasing order.
 *
 *         &gt;&gt;&gt; tstzset(timestamp_list=['2019-09-08 00:00:00+01', '2019-09-10 00:00:00+01', '2019-09-11 00:00:00+01'])
 *         &gt;&gt;&gt; tstzset(timestamp_list=[parse('2019-09-08 00:00:00+01'), parse('2019-09-10 00:00:00+01'), parse('2019-09-11 00:00:00+01')])
 * &lt;/pre&gt;
 * @author Arijit Samal
 */
public class tstzset extends Set&lt;LocalDateTime&gt; implements Time, TimeCollection {
<span class="pc" id="L44">	private final List&lt;OffsetDateTime&gt; dateTimeList = null;</span>
	private Pointer _inner;


    /* ------------------------- Constructors ---------------------------------- */


	/**
	 * The default constructor
	 */
<span class="nc" id="L54">	public tstzset() {</span>
<span class="nc" id="L55">	}</span>

	/**
	 * Pointer constructor
	 * @param _inner Pointer
	 */
	public tstzset(Pointer _inner)  {
<span class="fc" id="L62">		super(_inner);</span>
<span class="fc" id="L63">		this._inner = _inner;</span>
		//String str = functions.timestampset_out(this._inner);
<span class="fc" id="L65">	}</span>
	
	
	/**
	 * The string constructor
	 *
	 * @param value - a string with a tstzset value
	 */
	public tstzset(String value) {
<span class="fc" id="L74">		super(value);</span>
<span class="fc" id="L75">		this._inner = functions.tstzset_in(value);</span>
<span class="fc" id="L76">	}</span>


	@Override
	public Pointer createStringInner(String str){
<span class="fc" id="L81">		return functions.tstzset_in(str);</span>
	}

	@Override
	public Pointer createInner(Pointer inner){
<span class="fc" id="L86">		return inner;</span>
	}


	/**
	 * Return a copy of &quot;this&quot;.
	 *&lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;set_copy&lt;/li&gt;
	 * @return a new tstzset instance
	 */
//	public tstzset copy() {
//		return new tstzset(functions.tstz(this._inner));
//	}


	/**
	 * Returns a &quot;tstzset&quot; from its WKB representation in hex-encoded ASCII.
	 *  &lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;set_from_hexwkb&lt;/li&gt;
	 * @param hexwkb WKB representation in hex-encoded ASCII
	 * @return a new tstzset instance
	 */
//	public static tstzset from_hexwkb(String hexwkb) {
//		Pointer result = functions.tstzset_(hexwkb);
//		return new tstzset(result);
//	}

	public static tstzset from_hexwkb(String hexwkb) {
<span class="fc" id="L116">		Pointer result = functions.set_from_hexwkb(hexwkb);</span>
<span class="fc" id="L117">		return new tstzset(result);</span>
	}

    /* ------------------------- Output ---------------------------------------- */


	/**
	 * Return the string representation of the content of &quot;this&quot;.
	 *&lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;set_out&lt;/li&gt;
	 * @return a new String instance
	 */
	public String toString(){
<span class="fc" id="L131">		return functions.tstzset_out(this._inner);</span>
	}


    /* ------------------------- Conversions ----------------------------------- */


	/**
	 * Returns a tstzspanset that contains a tstzspan for each Timestamp in &quot;this&quot;.
	 *&lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;set_to_spanset&lt;/li&gt;
	 * @return a new tstzspanset instance
	 */
	public tstzspanset to_periodset() {
<span class="nc" id="L146">		return new tstzspanset(functions.set_to_spanset(this.get_inner()));</span>
	}

	/**
	 * Returns a period that encompasses &quot;this&quot;.
	 *&lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;set_span&lt;/li&gt;
	 * @return a new tstzspan instance
	 */
	public tstzspan to_span() {
<span class="fc" id="L157">		return new tstzspan(functions.set_to_span(this._inner));</span>
	}

	public tstzspanset to_spanset() {
<span class="fc" id="L161">		return new tstzspanset(functions.set_to_spanset(this._inner));</span>
	}

	/**
	 * Returns a period that encompasses &quot;this&quot;.
	 *&lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;set_span&lt;/li&gt;
	 * @return a new tstzspan instance
	 */
	public tstzspan to_period() {
<span class="nc" id="L172">		return this.to_span();</span>
	}

	public Duration duration(){
<span class="nc" id="L176">		return ConversionUtils.interval_to_timedelta(functions.tstzspan_duration(functions.set_to_span(this._inner)));</span>
	}





	/** ------------------------- Accessors ------------------------------------- */


	public Pointer get_inner(){
<span class="fc" id="L187">		return this._inner;</span>
	}


	/**
	 * Returns the number of timestamps in &quot;this&quot;.
	 * &lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;set_num_values&lt;/li&gt;
	 * @return a new Integer instance
	 */
	public int num_timestamps(){
<span class="nc" id="L199">		return functions.set_num_values(this._inner);</span>
	}

	/**
	 * Returns the first timestamp in &quot;this&quot;.
	 *  &lt;p&gt;
	 *
	 *         MEOS Functions:
	 *             &lt;li&gt;timestampset_start_timestamp&lt;/li&gt;
	 *
	 * @return a {@link LocalDateTime instance}
	 */
	public LocalDateTime start_element(){
<span class="fc" id="L212">		return ConversionUtils.timestamptz_to_datetime(functions.tstzset_start_value(this._inner));</span>
	}

	/**
	 * Returns the last timestamp in &quot;this&quot;.
	 *  &lt;p&gt;
	 *
	 *         MEOS Functions:
	 *             &lt;li&gt;timestampset_end_timestamp&lt;/li&gt;
	 *
	 * @return a {@link LocalDateTime instance}
	 */
	public LocalDateTime end_element(){
<span class="fc" id="L225">		return ConversionUtils.timestamptz_to_datetime(functions.tstzset_end_value(this._inner));</span>
	}

	public LocalDateTime element_n(int n) throws Exception {
<span class="nc" id="L229">		super.element_n(n);</span>
<span class="nc" id="L230">		return ConversionUtils.timestamptz_to_datetime(OffsetDateTime.parse(Objects.requireNonNull(functions.tstzset_value_n(this._inner, n + 1)).toString()));</span>
	}

	public List&lt;LocalDateTime&gt; elements() throws Exception {
<span class="nc" id="L234">		Pointer dp= functions.tstzset_values(this._inner);</span>
<span class="nc" id="L235">		long size= this.num_elements();</span>
<span class="nc" id="L236">		List&lt;LocalDateTime&gt; dateTimeList= new ArrayList&lt;LocalDateTime&gt;();</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">		for(int i=0; i&lt;size; i++) {</span>
<span class="nc" id="L238">			dateTimeList.add(ConversionUtils.timestamptz_to_datetime(OffsetDateTime.parse(dp.getPointer((long) i *Long.BYTES).toString())));</span>
		}
<span class="nc" id="L240">		return dateTimeList;</span>
	}



	public tstzset scale(Integer duration){
<span class="nc" id="L246">		return new tstzset(this.shift_scale(0, duration)._inner);</span>
	}

	public tstzset shift(Integer shift, Integer duration){
<span class="nc" id="L250">		return new tstzset(this.shift_scale(shift, 0)._inner);</span>
	}

	public tstzset shift_scale(Integer shift, Integer duration){
<span class="nc" id="L254">		return new tstzset(functions.tstzset_shift_scale(this._inner, ConversionUtils.timedelta_to_interval(Duration.ofDays(shift)), ConversionUtils.timedelta_to_interval(Duration.ofDays(duration))));</span>
	}

	/**
	 * Return the hash representation of &quot;this&quot;.
	 *&lt;p&gt;
	 *         MEOS Functions:
	 *             &lt;li&gt;set_hash&lt;/li&gt;
	 * @return a new Integer instance
	 */
	public long hash(){
<span class="fc" id="L265">		return functions.set_hash(this._inner);</span>
	}


    /* ------------------------- Topological Operations ------------------------ */


    /**
     * Returns whether &quot;this&quot; is temporally adjacent to &quot;other&quot;. That is, they share a bound but only one of them
     *         contains it.
     * &lt;pre&gt;
     *         Examples:
     *             &gt;&gt;&gt; tstzset('{2012-01-01, 2012-01-02}').is_adjacent(tstzspan('[2012-01-02, 2012-01-03]'))
     *             &gt;&gt;&gt; True
     *             &gt;&gt;&gt; tstzset('{2012-01-01, 2012-01-02}').is_adjacent(tstzspan('[2012-01-02, 2012-01-03]'))
     *             &gt;&gt;&gt; False  # Both contain bound
     *             &gt;&gt;&gt; tstzset('{2012-01-01, 2012-01-02}').is_adjacent(tstzspan('(2012-01-02, 2012-01-03]'))
     *             &gt;&gt;&gt; False  # Neither contain bound
     *&lt;/pre&gt;
     *         MEOS Functions:
     *         &lt;ul&gt;
     *              &lt;li&gt;adjacent_span_span&lt;/li&gt;
     *              &lt;li&gt;adjacent_spanset_span&lt;/li&gt;
     *         &lt;/ul&gt;
     * @param other temporal object to compare with
     * @return true if adjacent, false otherwise
     */
	public boolean is_adjacent(TemporalObject other) throws Exception {
<span class="nc bnc" id="L293" title="All 2 branches missed.">		if(other instanceof Span){</span>
<span class="nc" id="L294">			return super.is_adjacent((Base) other);</span>
		}
<span class="nc bnc" id="L296" title="All 2 branches missed.">		else if (other instanceof SpanSet){</span>
<span class="nc" id="L297">			return super.is_adjacent((Base) other);</span>
		}
<span class="nc bnc" id="L299" title="All 2 branches missed.">		else if (other instanceof Temporal){</span>
<span class="nc" id="L300">			return this.is_adjacent(((Temporal&lt;?&gt;) other).time());</span>
		}
<span class="nc bnc" id="L302" title="All 2 branches missed.">		else if (other instanceof Box){</span>
<span class="nc" id="L303">			return functions.adjacent_span_span(functions.set_to_span(this._inner), ((Box) other).to_period().get_inner());</span>
		}
		else{
<span class="nc" id="L306">			return super.is_adjacent((Base) other);</span>
		}
	}


    /**
      Returns whether &quot;this&quot; is temporally contained in &quot;other&quot;.
     &lt;pre&gt;
              Examples:
                  &gt;&gt;&gt; tstzset('{2012-01-02, 2012-01-03}').is_contained_in(tstzspan('[2012-01-01, 2012-01-04]'))
                  &gt;&gt;&gt; True
                  &gt;&gt;&gt; tstzset('{2012-01-01, 2012-01-02}').is_contained_in(tstzspan('[2012-01-01, 2012-01-02]'))
                  &gt;&gt;&gt; True
                  &gt;&gt;&gt; tstzset('{2012-01-01, 2012-01-02}').is_contained_in(tstzspan('(2012-01-01, 2012-01-02)'))
                  &gt;&gt;&gt; False
     &lt;/pre&gt;
              MEOS Functions:
              &lt;ul&gt;
                   &lt;li&gt;contained_span_span&lt;/li&gt;
                   &lt;li&gt;contained_span_spanset&lt;/li&gt;
                   &lt;li&gt;contained_set_set&lt;/li&gt;
                   &lt;li&gt;contained_spanset_spanset&lt;/li&gt;
              &lt;/ul&gt;

      @param other temporal object to compare with
     * @return true if contained, false otherwise
     * @throws Exception
     */
	public boolean is_contained_in(TemporalObject other) throws Exception {
		boolean returnValue;
<span class="nc bnc" id="L336" title="All 5 branches missed.">		switch (other) {</span>
<span class="nc" id="L337">			case tstzspan p -&gt; returnValue = functions.contained_span_span(functions.set_to_span(this._inner), p.get_inner());</span>
<span class="nc" id="L338">			case tstzspanset ps -&gt; returnValue = functions.contained_spanset_spanset(functions.set_to_span(this._inner), ps.get_inner());</span>
<span class="nc" id="L339">			case Temporal t -&gt; returnValue = this.is_contained_in(t.time());</span>
<span class="nc" id="L340">			case Box b -&gt; returnValue = functions.contained_span_span(functions.set_to_span(this._inner), b.to_period().get_inner());</span>
<span class="nc" id="L341">			default -&gt; returnValue = super.is_contained_in((Base) other);</span>
		}
<span class="nc" id="L343">		return returnValue;</span>
	}




    /**
     * Returns whether &quot;this&quot; temporally contains &quot;other&quot;.
     *&lt;pre&gt;
     *         Examples:
     *             &gt;&gt;&gt; tstzset('{2012-01-01, 2012-01-04}').contains(parse('2012-01-01]'))
     *             &gt;&gt;&gt; True
     *             &gt;&gt;&gt; tstzset('{2012-01-01, 2012-01-02}').contains(tstzset('{2012-01-01}'))
     *             &gt;&gt;&gt; True
     *             &gt;&gt;&gt; tstzset('{2012-01-01, 2012-01-02}').contains(tstzset('{2012-01-01, 2012-01-03}'))
     *             &gt;&gt;&gt; False
     *&lt;/pre&gt;
     *         MEOS Functions:
     *         &lt;ul&gt;
     *             &lt;li&gt;contains_timestampset_timestamp&lt;/li&gt;
     *             &lt;li&gt;contains_set_set&lt;/li&gt;
     *             &lt;li&gt;contains_spanset_spanset&lt;/li&gt;
     *         &lt;/ul&gt;
     * @param other temporal object to compare with
     * @return true if contains, false otherwise
	 * @throws Exception
     */
	public boolean contains(TemporalObject other) throws Exception {
		boolean returnValue;
<span class="nc bnc" id="L372" title="All 3 branches missed.">		switch (other) {</span>
<span class="nc" id="L373">			case tstzset ts -&gt; returnValue = functions.contains_set_set(this._inner, ts.get_inner());</span>
<span class="nc" id="L374">			case Temporal t -&gt; returnValue = this.contains(t.time());</span>
<span class="nc" id="L375">			default -&gt; returnValue = super.contains((Base) other);</span>
		}
<span class="nc" id="L377">		return returnValue;</span>
	}


    /**
      Returns whether &quot;this&quot; temporally overlaps &quot;other&quot;. That is, both share at least an instant
      &lt;pre&gt;
              Examples:
                  &gt;&gt;&gt; tstzset('{2012-01-01, 2012-01-02}').overlaps(tstzset('{2012-01-02, 2012-01-03}'))
                  &gt;&gt;&gt; True
                  &gt;&gt;&gt; tstzset('{2012-01-01, 2012-01-02}').overlaps(tstzspan('[2012-01-02, 2012-01-03]'))
                  &gt;&gt;&gt; True
                  &gt;&gt;&gt; tstzset('{2012-01-01, 2012-01-02}').overlaps(tstzspan('(2012-01-02, 2012-01-03]'))
                  &gt;&gt;&gt; False
     &lt;/pre&gt;

              MEOS Functions:
              &lt;ul&gt;
                   &lt;li&gt;overlaps_set_set&lt;/li&gt;
                   &lt;li&gt;overlaps_span_span&lt;/li&gt;
                   &lt;li&gt;overlaps_spanset_spanset&lt;/li&gt;
              &lt;/ul&gt;

      @param other temporal object to compare with
     * @return true if overlaps, false otherwise
	 * @throws  Exception
     */
	public boolean overlaps(TemporalObject other) throws Exception {
		boolean returnValue;
<span class="nc bnc" id="L406" title="All 5 branches missed.">		switch (other) {</span>
<span class="nc" id="L407">			case tstzspan p -&gt; returnValue = functions.overlaps_span_span(functions.set_to_span(this._inner), p.get_inner());</span>
<span class="nc" id="L408">			case tstzspanset ps -&gt; returnValue = functions.overlaps_spanset_spanset(functions.set_to_spanset(this._inner), ps.get_inner());</span>
<span class="nc" id="L409">			case tstzset ts -&gt; returnValue = functions.overlaps_set_set(this._inner, ts.get_inner());</span>
<span class="nc" id="L410">			case Box b -&gt; returnValue = functions.overlaps_span_span(functions.set_to_span(this._inner), b.to_period().get_inner());</span>
<span class="nc" id="L411">			default -&gt; returnValue = super.overlaps((Base) other);</span>
		}
<span class="nc" id="L413">		return returnValue;</span>
	}




    /**
     * Returns whether the bounding period of &quot;this&quot; is the same as the bounding period of &quot;other&quot;.
     *
     *         See Also:
     *             {@link tstzspan#is_same(TemporalObject)}
     * @param other A time or temporal object to compare to `self`.
     * @return true if same, false otherwise.
     */
	public boolean is_same(Time other) throws Exception {
<span class="nc" id="L428">		return this.to_period().is_same(other);</span>
	}


    /* ------------------------- Position Operations --------------------------- */


    /**
     * Returns whether &quot;this&quot; is strictly after &quot;other&quot;. That is, the first timestamp in &quot;this&quot;
     *         is after &quot;other&quot;.
     * &lt;pre&gt;
     *         Examples:
     *             &gt;&gt;&gt; tstzset('{2012-01-02, 2012-01-03}').is_after(tstzspan('[2012-01-01, 2012-01-02)'))
     *             &gt;&gt;&gt; True
     *             &gt;&gt;&gt; tstzset('{2012-01-02, 2012-01-03}').is_after(tstzset('{2012-01-01}'))
     *             &gt;&gt;&gt; True
     *             &gt;&gt;&gt; tstzset('{2012-01-02, 2012-01-03}').is_after(tstzspan('[2012-01-01, 2012-01-02]'))
     *             &gt;&gt;&gt; False
     *&lt;/pre&gt;
     *
     *         MEOS Functions:
     *         &lt;ul&gt;
     *         &lt;li&gt; overbefore_timestamp_timestampset&lt;/li&gt;
     *         &lt;li&gt; right_set_set&lt;/li&gt;
     *         &lt;li&gt; right_span_span&lt;/li&gt;
     *         &lt;li&gt; right_span_spanset&lt;/li&gt;
     *         &lt;/ul&gt;
     *
     *
     *
     * @param other temporal object to compare with
     * @return true if after, false otherwise
	 * @throws  Exception
     */
	public boolean is_after(TemporalObject other) throws Exception {
		boolean returnValue;
<span class="pc bpc" id="L464" title="5 of 6 branches missed.">		switch (other) {</span>
<span class="nc" id="L465">			case tstzspan p -&gt; returnValue = functions.right_span_span(functions.set_to_span(this._inner), p.get_inner());</span>
<span class="nc" id="L466">			case tstzspanset ps -&gt; returnValue = functions.right_span_spanset(functions.set_to_span(this._inner), ps.get_inner());</span>
<span class="fc" id="L467">			case tstzset ts -&gt; returnValue = functions.right_set_set(this._inner, ts.get_inner());</span>
<span class="nc" id="L468">			case Temporal t -&gt; returnValue = this.to_period().is_after(other);</span>
<span class="nc" id="L469">			case Box b -&gt; returnValue = functions.right_span_span(functions.set_to_span(this._inner), b.to_period().get_inner());</span>
<span class="nc" id="L470">			default -&gt; returnValue = super.is_left((Base) other);</span>
		}
<span class="fc" id="L472">		return returnValue;</span>
	}


	/**
	 * Returns whether &quot;this&quot; is strictly before &quot;other&quot;. That is, &quot;this&quot; ends before &quot;other&quot; starts.
	 *
	 * &lt;pre&gt;
	 *         Examples:
	 *             &gt;&gt;&gt; tstzset('{2012-01-01, 2012-01-02}').is_before(tstzset('{2012-01-03}'))
	 *             &gt;&gt;&gt; True
	 *             &gt;&gt;&gt; tstzset('{2012-01-01, 2012-01-02}').is_before(tstzspan('(2012-01-02, 2012-01-03]'))
	 *             &gt;&gt;&gt; True
	 *             &gt;&gt;&gt; tstzset('{2012-01-01, 2012-01-02}').is_before(tstzspan('[2012-01-02, 2012-01-03]'))
	 *             &gt;&gt;&gt; False
	 * &lt;/pre&gt;
	 *         MEOS Functions:
	 *         	   &lt;ul&gt;
	 *             &lt;li&gt;overafter_timestamp_period&lt;/li&gt;
	 *             &lt;li&gt;left_span_span&lt;/li&gt;
	 *             &lt;li&gt;left_span_spanset&lt;/li&gt;
	 *             &lt;/ul&gt;
	 *
	 * @param other: temporal object to compare with
	 * @return true if before, false otherwise
	 * @throws  Exception
	 */
	public boolean is_before(TemporalObject other) throws Exception {
		boolean returnValue;
<span class="pc bpc" id="L501" title="5 of 6 branches missed.">		switch (other) {</span>
<span class="nc" id="L502">			case tstzspan p -&gt; returnValue = functions.left_span_span(functions.set_to_span(this._inner), p.get_inner());</span>
<span class="nc" id="L503">			case tstzspanset ps -&gt; returnValue = functions.left_span_spanset(functions.set_to_span(this._inner), ps.get_inner());</span>
<span class="fc" id="L504">			case tstzset ts -&gt; returnValue = functions.left_set_set(this._inner, ts.get_inner());</span>
<span class="nc" id="L505">			case Temporal t -&gt; returnValue = this.to_period().is_before(other);</span>
<span class="nc" id="L506">			case Box b -&gt; returnValue = functions.left_span_span(functions.set_to_span(this._inner), b.to_period().get_inner());</span>
<span class="nc" id="L507">			default -&gt; returnValue = super.is_left((Base) other);</span>
		}
<span class="fc" id="L509">		return returnValue;</span>
	}


	/**
	 * Returns whether &quot;this&quot; is after &quot;other&quot; allowing overlap. That is, &quot;this&quot; starts after &quot;other&quot; starts
	 *         (or at the same time).
	 * &lt;pre&gt;
	 *         Examples:
	 *             &gt;&gt;&gt; tstzset('{2012-01-02, 2012-01-03}').is_over_or_after(tstzspan('[2012-01-01, 2012-01-02)'))
	 *             &gt;&gt;&gt; True
	 *             &gt;&gt;&gt; tstzset('{2012-01-02, 2012-01-03}').is_over_or_after(tstzspan('[2012-01-01, 2012-01-02]'))
	 *             &gt;&gt;&gt; True
	 *             &gt;&gt;&gt; tstzset('{2012-01-02, 2012-01-03}').is_over_or_after(tstzspan('[2012-01-01, 2012-01-03]'))
	 *             &gt;&gt;&gt; False
	 *&lt;/pre&gt;
	 *         MEOS Functions:
	 *         &lt;ul&gt;
	 *         &lt;li&gt;overafter_period_timestamp&lt;/li&gt;
	 *         &lt;li&gt;overright_span_span&lt;/li&gt;
	 *         &lt;li&gt;overright_span_spanset&lt;/li&gt;
	 *         &lt;/ul&gt;
	 *
	 * @param other temporal object to compare with
	 * @return true if overlapping or after, false otherwise
	 */
	public boolean is_over_or_after(TemporalObject other) throws Exception {
		boolean returnValue;
<span class="pc bpc" id="L537" title="5 of 6 branches missed.">		switch (other) {</span>
<span class="nc" id="L538">			case tstzspan p -&gt; returnValue = functions.overright_span_span(functions.set_to_span(this._inner), p.get_inner());</span>
<span class="nc" id="L539">			case tstzspanset ps -&gt; returnValue = functions.overright_span_spanset(functions.set_to_span(this._inner), ps.get_inner());</span>
<span class="fc" id="L540">			case tstzset ts -&gt; returnValue = functions.overright_set_set(this._inner, ts.get_inner());</span>
<span class="nc" id="L541">			case Temporal t -&gt; returnValue = this.to_period().is_over_or_after(other);</span>
<span class="nc" id="L542">			case Box b -&gt; returnValue = functions.overright_span_span(functions.set_to_span(this._inner), b.to_period().get_inner());</span>
<span class="nc" id="L543">			default -&gt; returnValue = super.is_over_or_right((Base) other);</span>
		}
<span class="fc" id="L545">		return returnValue;</span>
	}


	/**
	 * Returns whether &quot;this&quot; is before &quot;other&quot; allowing overlap. That is, &quot;this&quot; ends before &quot;other&quot; ends (or
	 *         at the same time).
	 * &lt;pre&gt;
	 *         Examples:
	 *             &gt;&gt;&gt; tstzset('{2012-01-01, 2012-01-02}').is_over_or_before(tstzspan('[2012-01-02, 2012-01-03]'))
	 *             &gt;&gt;&gt; True
	 *             &gt;&gt;&gt; tstzset('{2012-01-01, 2012-01-02}').is_over_or_before(tstzspan('[2012-01-02, 2012-01-03]'))
	 *             &gt;&gt;&gt; True
	 *             &gt;&gt;&gt; tstzset('{2012-01-03, 2012-01-05}').is_over_or_before(tstzspan('[2012-01-01, 2012-01-04]'))
	 *             &gt;&gt;&gt; False
	 *&lt;/pre&gt;
	 *         MEOS Functions:
	 *         &lt;ul&gt;
	 *             &lt;li&gt;overbefore_period_timestamp&lt;/li&gt;
	 *             &lt;li&gt;overleft_span_span&lt;/li&gt;
	 *             &lt;li&gt;overleft_span_spanset&lt;/li&gt;
	 *             &lt;/ul&gt;
	 *
	 * @param other temporal object to compare with
	 * @return true if before, false otherwise
	 * @throws  Exception
	 */
	public boolean is_over_or_before(TemporalObject other) throws Exception {
		boolean returnValue;
<span class="pc bpc" id="L574" title="5 of 6 branches missed.">		switch (other) {</span>
<span class="nc" id="L575">			case tstzspan p -&gt; returnValue = functions.overleft_span_span(functions.set_to_span(this._inner), p.get_inner());</span>
<span class="nc" id="L576">			case tstzspanset ps -&gt; returnValue = functions.overleft_span_spanset(functions.set_to_span(this._inner), ps.get_inner());</span>
<span class="fc" id="L577">			case tstzset ts -&gt; returnValue = functions.overleft_set_set(this._inner, ts.get_inner());</span>
<span class="nc" id="L578">			case Temporal t -&gt; returnValue = this.to_period().is_over_or_before(other);</span>
<span class="nc" id="L579">			case Box b -&gt; returnValue = functions.overleft_span_span(functions.set_to_span(this._inner), b.to_period().get_inner());</span>
<span class="nc" id="L580">			default -&gt; returnValue = super.is_over_or_left((Base) other);</span>
		}
<span class="fc" id="L582">		return returnValue;</span>
	}

    /* ------------------------- Distance Operations --------------------------- */
	public Duration distance(Object other) throws Exception {
<span class="fc" id="L587">		Duration answer = null;</span>
<span class="pc bpc" id="L588" title="1 of 2 branches missed.">		if (other instanceof LocalDateTime) {</span>
<span class="nc" id="L589">			answer= Duration.ofSeconds((long)functions.distance_set_timestamptz(this._inner, ConversionUtils.datetimeToTimestampTz((LocalDateTime) other)));</span>
<span class="pc bpc" id="L590" title="1 of 2 branches missed.">		} else if (other instanceof tstzset) {</span>
<span class="fc" id="L591">			answer= Duration.ofSeconds((long)functions.distance_tstzset_tstzset(this._inner, ((tstzset) other)._inner));</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">		} else if (other instanceof tstzspan) {</span>
<span class="nc" id="L593">			answer= Duration.ofSeconds((long)this.to_span().distance((TemporalObject) other));</span>
//					Duration.ofSeconds((long)functions.distance_tstzspanset_tstzspan(this.to_spanset(tstzspan.class).get_inner(), ((tstzspan) other).get_inner()));
<span class="nc bnc" id="L595" title="All 2 branches missed.">		} else if (other instanceof tstzspanset) {</span>
<span class="nc" id="L596">			answer= Duration.ofSeconds((long)this.to_span().distance((TemporalObject) other));</span>
//					Duration.ofSeconds((long)functions.distance_tstzspanset_tstzspanset(this.to_spanset(tstzspan.class).get_inner(), ((tstzspanset) other).get_inner()));
<span class="nc bnc" id="L598" title="All 2 branches missed.">		} else if (other instanceof Temporal) {</span>
<span class="nc" id="L599">			answer= Duration.ofSeconds((long)this.to_span().distance((TemporalObject) other));</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">		} else if (other instanceof Box) {</span>
<span class="nc" id="L601">			answer= Duration.ofSeconds((long)this.to_span().distance((TemporalObject) other));</span>
		} else {
<span class="nc" id="L603">			throw new Exception(&quot;Operation not supported with &quot;+ other + &quot; type&quot;);</span>
		}
<span class="fc" id="L605">        return answer;</span>
    }

//	public Duration distance(Object other) throws Exception {
//		Duration answer = switch (other) {
//            case LocalDateTime localDateTime -&gt; Duration.ofSeconds((long) functions.distance_set_timestamptz(this._inner, ConversionUtils.datetimeToTimestampTz(localDateTime)));
//            case tstzset tstzset -&gt; Duration.ofSeconds((long) functions.distance_tstzset_tstzset(this._inner, tstzset._inner));
//            case tstzspan tstzspan -&gt; Duration.ofSeconds((long) tstzspan.distance((TemporalObject) other));
//            case tstzspanset tstzspanset -&gt; Duration.ofSeconds((long) tstzspanset.to_span().distance((TemporalObject) other));
//            case Temporal ts -&gt; Duration.ofSeconds((long) this.to_span().distance((TemporalObject) other));
//            case Box box -&gt; Duration.ofSeconds((long) this.to_span().distance((TemporalObject) other));
//            case null, default -&gt; throw new TypeNotPresentException(other.getClass().toString(), new Throwable(&quot;Operation not supported with this type&quot;));
//        };
//        return answer;
//	}


//	public double distance(TemporalObject other) throws Exception {
//		double returnValue;
//		switch (other){
//			case tstzspan p -&gt; returnValue = this.to_span().distance(other);
//			case tstzset ts -&gt; returnValue = functions.distance_tstzspanset_tstzspan(ts.get_inner(),this._inner);
//			case Box b -&gt; returnValue = functions.distance_tstzspan_tstzspan(this._inner, b.to_period().get_inner());
//			default -&gt; throw new TypeNotPresentException(other.getClass().toString(), new Throwable(&quot;Operation not supported with this type&quot;));
//		}
//		return returnValue;
//	}




    /* ------------------------- Set Operations -------------------------------- */

	/**
	 * Returns the temporal intersection of &quot;this&quot; and &quot;other&quot;.
	 *
	 *         MEOS Functions:
	 *         &lt;ul&gt;
	 *         &lt;li&gt;intersection_set_set&lt;/li&gt;
	 *         &lt;li&gt;intersection_spanset_span&lt;/li&gt;
	 *         &lt;li&gt;intersection_spanset_spanset&lt;/li&gt;
	 *         &lt;/ul&gt;
	 *
	 * @param other temporal object to intersect with
	 * @return a Time instance. The actual class depends on &quot;other&quot;.
	 */
	public Time intersection(TemporalObject other) throws Exception {
<span class="fc" id="L652">		Time returnValue = null;</span>
<span class="pc bpc" id="L653" title="3 of 6 branches missed.">		switch (other) {</span>
<span class="fc" id="L654">			case tstzspan p -&gt; returnValue = new tstzspanset(functions.intersection_spanset_span(functions.set_to_spanset(this._inner), p.get_inner()));</span>
<span class="fc" id="L655">			case tstzspanset ps -&gt; returnValue = new tstzspanset(functions.intersection_spanset_spanset(functions.set_to_spanset(this._inner),ps.get_inner()));</span>
<span class="fc" id="L656">			case tstzset ts -&gt; returnValue = new tstzset(functions.intersection_set_set(this._inner,ts.get_inner()));</span>
<span class="nc" id="L657">			case Temporal t -&gt; returnValue = (Time) this.intersection(t.time());</span>
<span class="nc" id="L658">			case Box b -&gt; returnValue = (Time) this.intersection(b.to_period());</span>
<span class="nc" id="L659">			default -&gt; throw new TypeNotPresentException(other.getClass().toString(), new Throwable(&quot;Operation not supported with this type&quot;));</span>
		}
<span class="fc" id="L661">		return returnValue;</span>
	}

	/**
	 * Returns the temporal intersection of &quot;this&quot; and &quot;other&quot;.
	 *
	 *         MEOS Functions:
	 *         &lt;ul&gt;
	 *         &lt;li&gt;intersection_set_set&lt;/li&gt;
	 *         &lt;li&gt;intersection_spanset_span&lt;/li&gt;
	 *         &lt;li&gt;intersection_spanset_spanset&lt;/li&gt;
	 *         &lt;/ul&gt;
	 *
	 * @param other temporal object to intersect with
	 * @return a Time instance. The actual class depends on &quot;other&quot;.
	 */
	public Time mul(TemporalObject other) throws Exception {
<span class="nc" id="L678">		return this.intersection(other);</span>
	}


	/**
	 * Returns the temporal difference of &quot;this&quot; and &quot;other&quot;.
	 *
	 *         MEOS Functions:
	 *         &lt;ul&gt;
	 *             &lt;li&gt;minus_timestampset_timestamp&lt;/li&gt;
	 *             &lt;li&gt;minus_set_set&lt;/li&gt;
	 *             &lt;li&gt;minus_spanset_span&lt;/li&gt;
	 *             &lt;li&gt;minus_spanset_spanset&lt;/li&gt;
	 *         &lt;/ul&gt;
	 *
	 *
	 * @param other temporal object to diff with
	 * @return a Time instance. The actual class depends on &quot;other&quot;.
	 */
	public Time minus(TemporalObject other) throws Exception {
<span class="fc" id="L698">		Time returnValue = null;</span>
<span class="pc bpc" id="L699" title="3 of 6 branches missed.">		switch (other) {</span>
<span class="fc" id="L700">			case tstzspan p -&gt; returnValue = new tstzspanset(functions.minus_spanset_span(functions.set_to_spanset(this._inner), p.get_inner()));</span>
<span class="fc" id="L701">			case tstzspanset ps -&gt; returnValue = new tstzspanset(functions.minus_spanset_spanset(functions.set_to_spanset(this._inner),ps.get_inner()));</span>
<span class="fc" id="L702">			case tstzset ts -&gt; returnValue = new tstzset(functions.minus_set_set(this._inner,ts.get_inner()));</span>
<span class="nc" id="L703">			case Temporal t -&gt; returnValue = (Time) this.minus(t.time());</span>
<span class="nc" id="L704">			case Box b -&gt; returnValue = (Time) this.minus(b.to_period());</span>
<span class="nc" id="L705">			default -&gt; throw new TypeNotPresentException(other.getClass().toString(), new Throwable(&quot;Operation not supported with this type&quot;));</span>
		}
<span class="fc" id="L707">		return returnValue;</span>
	}


	/**
	 * Returns the temporal difference of &quot;this&quot; and &quot;other&quot;.
	 *
	 *         MEOS Functions:
	 *         &lt;ul&gt;
	 *             &lt;li&gt;minus_timestampset_timestamp&lt;/li&gt;
	 *             &lt;li&gt;minus_set_set&lt;/li&gt;
	 *             &lt;li&gt;minus_spanset_span&lt;/li&gt;
	 *             &lt;li&gt;minus_spanset_spanset&lt;/li&gt;
	 *         &lt;/ul&gt;
	 *
	 *
	 * @param other temporal object to diff with
	 * @return a Time instance. The actual class depends on &quot;other&quot;.
	 */
	public Time sub(Time other) throws Exception {
<span class="nc" id="L727">		return this.minus(other);</span>
	}

	/**
	 * Returns the temporal union of &quot;this&quot; and &quot;other&quot;.
	 *
	 *
	 *         MEOS Functions:
	 *         &lt;ul&gt;
	 *             &lt;li&gt;union_timestampset_timestamp&lt;/li&gt;
	 *             &lt;li&gt;union_set_set&lt;/li&gt;
	 *             &lt;li&gt;union_spanset_span&lt;/li&gt;
	 *             &lt;li&gt;union_spanset_spanset&lt;/li&gt;
	 *         &lt;/ul&gt;
	 * @param other temporal object to merge with
	 * @return a Time instance. The actual class depends on &quot;other&quot;.
	 */
	public Time union(TemporalObject other) throws Exception {
<span class="fc" id="L745">		Time returnValue = null;</span>
<span class="pc bpc" id="L746" title="3 of 6 branches missed.">		switch (other) {</span>
<span class="fc" id="L747">			case tstzspan p -&gt; returnValue = new tstzspan(functions.union_spanset_span(functions.set_to_spanset(this._inner),p.get_inner()));</span>
<span class="fc" id="L748">			case tstzspanset ps -&gt; returnValue = new tstzspanset(functions.union_spanset_spanset(functions.set_to_spanset(this._inner),ps.get_inner()));</span>
<span class="fc" id="L749">			case tstzset ts -&gt; returnValue =  new tstzset(functions.union_set_set(this._inner,ts.get_inner()));</span>
<span class="nc" id="L750">			case Temporal t -&gt; returnValue = (Time) this.union(t.time());</span>
<span class="nc" id="L751">			case Box b -&gt; returnValue = (Time) this.union(b.to_period());</span>
<span class="nc" id="L752">			default -&gt; throw new TypeNotPresentException(other.getClass().toString(), new Throwable(&quot;Operation not supported with this type&quot;));</span>
		}
<span class="fc" id="L754">		return returnValue;</span>
	}


	/**
	 * Returns the temporal union of &quot;this&quot; and &quot;other&quot;.
	 *
	 *
	 *         MEOS Functions:
	 *         &lt;ul&gt;
	 *             &lt;li&gt;union_timestampset_timestamp&lt;/li&gt;
	 *             &lt;li&gt;union_set_set&lt;/li&gt;
	 *             &lt;li&gt;union_spanset_span&lt;/li&gt;
	 *             &lt;li&gt;union_spanset_spanset&lt;/li&gt;
	 *         &lt;/ul&gt;
	 * @param other temporal object to merge with
	 * @return a Time instance. The actual class depends on &quot;other&quot;.
	 */
	public Time add(Time other) throws Exception {
<span class="nc" id="L773">		return this.union(other);</span>
	}


    /* ------------------------- Comparisons ----------------------------------- */

	/*
	  Returns whether &quot;this&quot; and &quot;other&quot; are equal.

	          MEOS Functions:
	          &lt;ul&gt;
	              &lt;li&gt;set_eq&lt;/li&gt;
	         &lt;/ul&gt;
	  @param other temporal object to compare with
	 * @return true if equal, false otherwise
	 * @throws SQLException
	 */
	/*
	public boolean eq(Time other) throws SQLException{
		boolean result;
		result = other instanceof tstzset ? functions.set_eq(this._inner,((tstzset) other).get_inner()) : false;
		return result;
	}

	 */

	/*
	  Returns whether &quot;this&quot; and &quot;other&quot; are not equal.

	  &lt;p&gt;
	          MEOS Functions:
	          &lt;ul&gt;
	              &lt;li&gt;set_ne&lt;/li&gt;
	          &lt;/ul&gt;
	  &lt;/p&gt;

	  @param other temporal object to compare with
	 * @return true if not equal, false otherwise
	 * @throws SQLException
	 */
	/*
	public boolean notEquals(Time other) throws SQLException{
		boolean result;
		result = other instanceof tstzset ? functions.set_ne(this._inner,((tstzset) other).get_inner()) : true;
		return result;
	}

	 */


	/*
	  Return whether &quot;this&quot; is less than &quot;other&quot;.

	  &lt;p&gt;
	          MEOS Functions:
	          &lt;ul&gt;
	              &lt;li&gt;set_lt&lt;/li&gt;
	          &lt;/ul&gt;
	  &lt;/p&gt;

	  @param other temporal object to compare with
	 * @return true if less than, false otherwise
	 * @throws SQLException
	 */
	/*
	public boolean lessThan(Time other) throws SQLException{
		if (other instanceof tstzset){
			return functions.set_lt(this._inner,((tstzset) other).get_inner());
		}
		else{
			throw new SQLException(&quot;Operation not supported with this type.&quot;);
		}
	}

	 */


	/*
	  Return whether &quot;this&quot; is less than or equal to &quot;other&quot;.

	  &lt;p&gt;
	          MEOS Functions:
	          &lt;ul&gt;
	              &lt;li&gt;set_le&lt;/li&gt;
	          &lt;/ul&gt;

	  &lt;/p&gt;

	  @param other temporal object to compare with
	 * @return true if less than or equal, false otherwise
	 * @throws SQLException
	 */
	/*
	public boolean lessThanOrEqual(Time other) throws SQLException{
		if (other instanceof tstzset){
			return functions.set_le(this._inner,((tstzset) other).get_inner());
		}
		else{
			throw new SQLException(&quot;Operation not supported with this type.&quot;);
		}
	}

	 */


	/*
	  Return whether &quot;this&quot; is greater than &quot;other&quot;.

	  &lt;p&gt;
	          MEOS Functions:
	          &lt;ul&gt;
	              &lt;li&gt;set_gt&lt;/li&gt;
	          &lt;/ul&gt;
	  &lt;/p&gt;

	  @param other temporal object to compare with
	 * @return true if greater than, false otherwise
	 * @throws SQLException
	 */
	/*
	public boolean greaterThan(Time other) throws SQLException{
		if (other instanceof tstzset){
			return functions.set_gt(this._inner,((tstzset) other).get_inner());
		}
		else{
			throw new SQLException(&quot;Operation not supported with this type.&quot;);
		}
	}

	 */


	/**
	 * Return whether &quot;this&quot; is greater than or equal to &quot;other&quot;.
	 *
	 * &lt;p&gt;
	 *         MEOS Functions:
	 *         &lt;ul&gt;
	 *             &lt;li&gt;set_ge&lt;/li&gt;
	 *         &lt;/ul&gt;
	 * &lt;/p&gt;
	 *
	 * @return true if greater than or equal, false otherwise
	 */
	/*
	public boolean greaterThanOrEqual(Time other) throws SQLException{
		if (other instanceof tstzset){
			return functions.set_ge(this._inner,((tstzset) other).get_inner());
		}
		else{
			throw new SQLException(&quot;Operation not supported with this type.&quot;);
		}
	}

	 */

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>