<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BuilderUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jmeos</a> &gt; <a href="index.source.html" class="el_package">utils</a> &gt; <span class="el_source">BuilderUtils.java</span></div><h1>BuilderUtils.java</h1><pre class="source lang-java linenums">package utils;

import java.io.*;
import java.util.*;
import java.util.function.Consumer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Java class for manipulating StringBuilders as well as strings to allow string modification, reading and file writing operations.
 *
 * @author Nidhal Mareghni and Killian Monnier
 * @since 27/07/2023
 */
<span class="nc" id="L15">public class BuilderUtils {</span>
	
	/**
	 * Writes lines to a file.
	 *
	 * @param lines    the list of extracted rows
	 * @param filePath the file path
	 */
	public static void writeFileFromArray(List&lt;String&gt; lines, String filePath) {
<span class="nc" id="L24">		try (BufferedWriter writer = new BufferedWriter(new FileWriter(filePath))) {</span>
<span class="nc bnc" id="L25" title="All 2 branches missed.">			for (String line : lines) {</span>
<span class="nc" id="L26">				writer.write(line);</span>
<span class="nc" id="L27">				writer.newLine();</span>
<span class="nc" id="L28">			}</span>
<span class="nc" id="L29">		} catch (IOException e) {</span>
<span class="nc" id="L30">			e.printStackTrace();</span>
<span class="nc" id="L31">		}</span>
<span class="nc" id="L32">	}</span>
	
	/**
	 * Allows writing a file with a StringBuilder.
	 *
	 * @param builder the builder
	 */
	public static void writeFileFromBuilder(StringBuilder builder, String filePath) {
<span class="nc" id="L40">		try (PrintWriter writer = new PrintWriter(new FileWriter(filePath))) {</span>
<span class="nc" id="L41">			writer.write(builder.toString());</span>
<span class="nc" id="L42">			System.out.println(&quot;The file &quot; + filePath + &quot; was created successfully!&quot;);</span>
<span class="nc" id="L43">		} catch (IOException e) {</span>
<span class="nc" id="L44">			System.out.println(&quot;Error creating file &quot; + filePath + &quot;: &quot; + e.getMessage());</span>
<span class="nc" id="L45">		}</span>
<span class="nc" id="L46">	}</span>
	
	/**
	 * Adding one builder to another.
	 *
	 * @param sourceBuilder the builder to add
	 * @param targetBuilder the builder who receives
	 * @param beginOfLine   each line begins with this string
	 * @param endOfLine     each line ends with this string
	 */
	public static void appendStringBuilders(StringBuilder sourceBuilder, StringBuilder targetBuilder, String beginOfLine, String endOfLine) {
<span class="nc" id="L57">		String[] lines = sourceBuilder.toString().split(&quot;\n&quot;);</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">		for (String line : lines) {</span>
<span class="nc" id="L59">			targetBuilder.append(beginOfLine).append(line).append(endOfLine);</span>
		}
<span class="nc" id="L61">	}</span>
	
	/**
	 * Allows to read lines iteratively from a builder.
	 *
	 * @param builder the builder in question
	 * @param line    the lambda expression to run
	 */
	public static void readBuilderLines(StringBuilder builder, Consumer&lt;String&gt; line) {
<span class="nc" id="L70">		String[] lines = builder.toString().split(&quot;\n&quot;);</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">		for (String builderLine : lines) {</span>

<span class="nc" id="L73">			line.accept(builderLine);</span>
		}
<span class="nc" id="L75">	}</span>
	
	/**
	 * Allows you to read the lines of a file and make changes to them.
	 *
	 * @param filepath file path
	 * @param line     lambda expression
	 */
	public static void readFileLines(String filepath, Consumer&lt;String&gt; line) {
<span class="nc" id="L84">		try (BufferedReader reader = new BufferedReader(new FileReader(filepath))) {</span>
			String stringLine;
<span class="nc bnc" id="L86" title="All 2 branches missed.">			while ((stringLine = reader.readLine()) != null) {</span>
<span class="nc" id="L87">				line.accept(stringLine);</span>
			}
<span class="nc" id="L89">		} catch (IOException e) {</span>
<span class="nc" id="L90">			System.out.println(&quot;Error reading file: &quot; + e.getMessage());</span>
<span class="nc" id="L91">		}</span>
<span class="nc" id="L92">	}</span>
	
	/**
	 * Extract lines matching a certain pattern from the file.
	 *
	 * @param filePath      file path
	 * @param regex_pattern the recovery pattern
	 * @return list of rows extracted
	 */
	public static ArrayList&lt;String&gt; extractPatternFromFile(String filePath, String regex_pattern) {
<span class="nc" id="L102">		ArrayList&lt;String&gt; lines = new ArrayList&lt;&gt;();</span>
		
<span class="nc" id="L104">		try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {</span>
<span class="nc" id="L105">			Pattern pattern = Pattern.compile(regex_pattern);</span>
			
			String line;
<span class="nc bnc" id="L108" title="All 2 branches missed.">			while ((line = reader.readLine()) != null) {</span>
<span class="nc" id="L109">				Matcher matcher = pattern.matcher(line);</span>

<span class="nc bnc" id="L111" title="All 2 branches missed.">				if (matcher.find()) {</span>
<span class="nc" id="L112">					lines.add(matcher.group());</span>
				}
<span class="nc" id="L114">			}</span>
<span class="nc" id="L115">		} catch (IOException e) {</span>
<span class="nc" id="L116">			e.printStackTrace();</span>
<span class="nc" id="L117">		}</span>
		
<span class="nc" id="L119">		return lines;</span>
	}
	
	/**
	 * Allows you to extract the name of a function.
	 *
	 * @param signature function signature
	 * @return the name of the function
	 */
	public static String extractFunctionName(String signature) {
		// Set regex pattern to extract function name
<span class="nc" id="L130">		String regex = &quot;\\b([A-Za-z_][A-Za-z0-9_]*)\\s*\\(&quot;;</span>
		
		// Create the pattern and the matcher for the signature
<span class="nc" id="L133">		Pattern pattern = Pattern.compile(regex);</span>
<span class="nc" id="L134">		Matcher matcher = pattern.matcher(signature);</span>
		
		// Check if the function name was found
<span class="nc bnc" id="L137" title="All 2 branches missed.">		if (matcher.find()) {</span>
<span class="nc" id="L138">			return matcher.group(1); // Return the first captured group</span>
		}
		
		// If no function name is found, return an empty string or handle the error as needed
<span class="nc" id="L142">		return &quot;&quot;;</span>
	}
	
	/**
	 * Allows to extract the types and names of the parameters of a function in order of appearance.
	 *
	 * @param signature function signature
	 * @return the list of parameter types and names in order of appearance
	 */
	public static ArrayList&lt;Pair&lt;String, String&gt;&gt; extractParamTypesAndNames(String signature) {
<span class="nc" id="L152">		ArrayList&lt;Pair&lt;String, String&gt;&gt; paramTypesAndNames = new ArrayList&lt;&gt;();</span>
		
		// Using a regular expression to extract parameter types and names
<span class="nc" id="L155">		Pattern pattern = Pattern.compile(&quot;(\\w+(?:\\[])?)\\s+(\\w+)\\b(?=\\s*,|\\s*\\))&quot;);</span>
<span class="nc" id="L156">		Matcher matcher = pattern.matcher(signature);</span>
		
<span class="nc bnc" id="L158" title="All 2 branches missed.">		while (matcher.find()) {</span>
<span class="nc" id="L159">			String paramType = matcher.group(1);</span>
<span class="nc" id="L160">			String paramName = matcher.group(2);</span>
<span class="nc" id="L161">			paramTypesAndNames.add(new Pair&lt;&gt;(paramType, paramName));</span>
<span class="nc" id="L162">		}</span>
		
<span class="nc" id="L164">		return paramTypesAndNames;</span>
	}
	
	/**
	 * Allows to extract the names of the parameters of a function.
	 *
	 * @param signature function signature
	 * @return the list of parameter names
	 */
	public static List&lt;String&gt; extractParamNames(String signature) {
<span class="nc" id="L174">		List&lt;String&gt; paramNames = new ArrayList&lt;&gt;();</span>
		
		// Using a regular expression to extract parameter names
<span class="nc" id="L177">		Pattern pattern = Pattern.compile(&quot;\\b\\w+\\b(?=\\s*,|\\s*\\))&quot;);</span>
<span class="nc" id="L178">		Matcher matcher = pattern.matcher(signature);</span>
		
<span class="nc bnc" id="L180" title="All 2 branches missed.">		while (matcher.find()) {</span>
<span class="nc" id="L181">			String paramName = matcher.group();</span>
<span class="nc" id="L182">			paramNames.add(paramName);</span>
<span class="nc" id="L183">		}</span>
		
<span class="nc" id="L185">		return paramNames;</span>
	}
	
	/**
	 * Gives the types of the function's parameters and return from a line corresponding to the format of a function.
	 *
	 * @param signature function signature
	 * @return types list
	 */
	public static ArrayList&lt;String&gt; extractFunctionTypes(String signature) {
<span class="nc" id="L195">		Pattern pattern = Pattern.compile(&quot;(\\w+(?:\\[])?)\\s+\\w+\\s*\\(([^)]*)\\)&quot;);</span>
<span class="nc" id="L196">		Matcher matcher = pattern.matcher(signature);</span>
		
<span class="nc" id="L198">		ArrayList&lt;String&gt; typesList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">		while (matcher.find()) {</span>
<span class="nc" id="L200">			String returnType = matcher.group(1);</span>
<span class="nc" id="L201">			String paramTypes = matcher.group(2);</span>
			
<span class="nc" id="L203">			ArrayList&lt;String&gt; paramTypeArray = new ArrayList&lt;&gt;(List.of(paramTypes.split(&quot;\\s\\w+,\\s|\\s\\w+&quot;)));</span>
			
<span class="nc bnc" id="L205" title="All 2 branches missed.">			if (!returnType.isBlank()) typesList.add(returnType); // added function return type</span>
<span class="nc bnc" id="L206" title="All 4 branches missed.">			if (!paramTypeArray.isEmpty()) if (!paramTypeArray.get(0).isEmpty()) typesList.addAll(paramTypeArray);</span>
<span class="nc" id="L207">		}</span>
		
<span class="nc" id="L209">		return typesList;</span>
	}
	
	/**
	 * Allows you to retrieve the values of a list without the [ ].
	 *
	 * @param list the list containing character strings
	 * @return a string of list values
	 */
	public static String getListWithoutBrackets(List&lt;String&gt; list) {
<span class="nc" id="L219">		String stringRepresentation = list.toString(); // Convert list to String</span>
<span class="nc" id="L220">		return stringRepresentation.replace(&quot;[&quot;, &quot;&quot;).replace(&quot;]&quot;, &quot;&quot;); // Remove '[' and ']'</span>
	}
	
	/**
	 * Delete it ; at the end of a line.
	 *
	 * @param input the line string
	 * @return the line without the semicolon
	 */
	public static String removeSemicolon(String input) {
<span class="nc bnc" id="L230" title="All 2 branches missed.">		if (input.endsWith(&quot;;&quot;)) {</span>
<span class="nc" id="L231">			return input.substring(0, input.length() - 1);</span>
		}
<span class="nc" id="L233">		return input;</span>
	}
	
	/**
	 * Extract all the keys from a {@link Pair} type.
	 *
	 * @param pairList list of pair
	 * @param &lt;K&gt;      key
	 * @param &lt;V&gt;      value
	 * @return list of keys of all the pairs
	 */
	public static &lt;K, V&gt; List&lt;K&gt; extractPairKeys(List&lt;Pair&lt;K, V&gt;&gt; pairList) {
<span class="nc" id="L245">		var keysList = new ArrayList&lt;K&gt;();</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">		for (var pair : pairList) {</span>
<span class="nc" id="L247">			keysList.add(pair.key());</span>
<span class="nc" id="L248">		}</span>
<span class="nc" id="L249">		return keysList;</span>
	}
	
	/**
	 * Extract all the values from a {@link Pair} type.
	 *
	 * @param pairList list of pair
	 * @param &lt;K&gt;      key
	 * @param &lt;V&gt;      value
	 * @return list of values of all the pairs
	 */
	public static &lt;K, V&gt; List&lt;V&gt; extractPairValues(List&lt;Pair&lt;K, V&gt;&gt; pairList) {
<span class="nc" id="L261">		var valuesList = new ArrayList&lt;V&gt;();</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">		for (var pair : pairList) {</span>
<span class="nc" id="L263">			valuesList.add(pair.value());</span>
<span class="nc" id="L264">		}</span>
<span class="nc" id="L265">		return valuesList;</span>
	}
	
	/**
	 * Retrieves the key corresponding to the specified value from the given map.
	 *
	 * @param map   the map containing key-value pairs
	 * @param value the value whose key is to be retrieved
	 * @param &lt;K&gt;   the type of keys in the map
	 * @param &lt;V&gt;   the type of values in the map
	 * @return the key associated with the specified value, or {@code null} if not found
	 */
	public static &lt;K, V&gt; K getKeyFromValue(Map&lt;K, V&gt; map, V value) {
<span class="nc bnc" id="L278" title="All 2 branches missed.">		for (Map.Entry&lt;K, V&gt; entry : map.entrySet()) {</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">			if (Objects.equals(value, entry.getValue())) {</span>
<span class="nc" id="L280">				return entry.getKey();</span>
			}
<span class="nc" id="L282">		}</span>
<span class="nc" id="L283">		return null; // value not found</span>
	}
	
	/**
	 * Modifies a list by replacing a target element with a new value.
	 *
	 * @param list   the original list.
	 * @param target the target element to be replaced.
	 * @param value  the new value to replace the target element.
	 * @return a new unmodifiable list with the target element replaced.
	 */
	public static List&lt;String&gt; modifyList(List&lt;String&gt; list, String target, String value) {
<span class="nc" id="L295">		List&lt;String&gt; modifiedList = new ArrayList&lt;&gt;(list);</span>
<span class="nc" id="L296">		int index = modifiedList.indexOf(target);</span>
		
<span class="nc bnc" id="L298" title="All 2 branches missed.">		if (index != -1) {</span>
<span class="nc" id="L299">			modifiedList.set(index, value);</span>
		}
		
<span class="nc" id="L302">		return Collections.unmodifiableList(modifiedList);</span>
	}
	
	/**
	 * Format all the lines in the list and return the string formatted.
	 *
	 * @param lines       list of lines
	 * @param beginOfLine characters of begin of each line
	 * @param endOfLine   characters of end of each line
	 * @return the lines concatenated and formatted
	 */
	public static String formattingLineList(List&lt;String&gt; lines, String beginOfLine, String endOfLine) {
<span class="nc" id="L314">		StringBuilder formattedString = new StringBuilder();</span>
		
<span class="nc bnc" id="L316" title="All 2 branches missed.">		for (String line : lines) {</span>
			/* Add beginOfLine at the beginning and endOfLine at the end of each line */
<span class="nc" id="L318">			formattedString.append(beginOfLine).append(line).append(endOfLine);</span>
<span class="nc" id="L319">		}</span>
		
<span class="nc" id="L321">		return formattedString.toString();</span>
	}
	
	/**
	 * Format the line and return the string formatted.
	 *
	 * @param line        line
	 * @param beginOfLine characters of begin of the line
	 * @param endOfLine   characters of end of the line
	 * @return the line formatted
	 */
	public static String formattingLine(String line, String beginOfLine, String endOfLine) {
<span class="nc" id="L333">		return beginOfLine + line + endOfLine;</span>
	}
	
	/**
	 * Replaces occurrences of types from the provided dictionary in the given line.
	 *
	 * @param typesReplacement a dictionary where keys are old types and values are new types.
	 * @param line             the input line of text containing type declarations.
	 * @return the line with replaced type occurrences.
	 */
	public static String replaceTypes(Map&lt;String, String&gt; typesReplacement, String line) {
<span class="nc bnc" id="L344" title="All 2 branches missed.">		for (Map.Entry&lt;String, String&gt; entry : typesReplacement.entrySet()) {</span>
<span class="nc" id="L345">			String oldType = entry.getKey();</span>
<span class="nc" id="L346">			String newType = entry.getValue();</span>
<span class="nc" id="L347">			line = line.replaceAll(&quot;(^|\\(|\\s)&quot; + oldType + &quot;(\\s|\\[\\])&quot;, &quot;$1&quot; + newType + &quot;$2&quot;);</span>
<span class="nc" id="L348">		}</span>
<span class="nc" id="L349">		return line;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>