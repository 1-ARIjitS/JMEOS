<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ConversionUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jmeos</a> &gt; <a href="index.source.html" class="el_package">utils</a> &gt; <span class="el_source">ConversionUtils.java</span></div><h1>ConversionUtils.java</h1><pre class="source lang-java linenums">package utils;

import com.google.common.collect.BoundType;
import functions.error_handler;
import jnr.ffi.Pointer;
import com.google.common.collect.Range;
import org.locationtech.jts.geom.Geometry;
import org.locationtech.jts.geom.Point;
import org.locationtech.jts.io.ParseException;
import org.locationtech.jts.io.WKTReader;
import org.locationtech.jts.io.WKTWriter;
//import types.temporal.TInstant;
//import types.temporal.TSequence;
//import types.temporal.TSequenceSet;
//import types.temporal.Temporal;

import java.sql.SQLException;
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import functions.functions;

/**
 * Class based on the manually-defined functions from PyMeos.
 * This class contains conversions functions for MEOS/JMEOS types.
 *
 * @author Killian Monnier and Nidhal Mareghni
 * @see &lt;a href=&quot;https://github.com/MobilityDB/PyMEOS/blob/9d84632df5a4b060d43421248c142af337ec4ddd/pymeos_cffi/pymeos_cffi/builder/build_pymeos_functions.py&quot;&gt;...&lt;/a&gt;
 * @since 09/08/2023
 */
<span class="nc" id="L33">public class ConversionUtils {</span>
	
	/**
	 * Take a {@link LocalDateTime} and convert it to an {@link OffsetDateTime}.
	 *
	 * @param dt localDateTime
	 * @return offsetDateTime
	 */
	public static OffsetDateTime datetimeToTimestampTz(LocalDateTime dt) {
<span class="fc" id="L42">		error_handler handler= new error_handler();</span>
<span class="fc" id="L43">		functions.meos_initialize(&quot;UTC&quot;, handler);</span>
<span class="fc" id="L44">		String formattedDt = dt.atZone(ZoneOffset.UTC).format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;));</span>
<span class="fc" id="L45">		return functions.pg_timestamptz_in(formattedDt, -1);</span>
	}

	
	/**
	 * Take a {@link OffsetDateTime} and convert it to an {@link LocalDateTime}.
	 *
	 * @param ts offsetDateTime
	 * @return localDateTime
	 */
	public static LocalDateTime timestamptz_to_datetime(OffsetDateTime ts) {
<span class="fc" id="L56">		DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ssX&quot;);</span>
		// Parse the string to LocalDateTime
<span class="fc" id="L58">		return LocalDateTime.parse(functions.pg_timestamptz_out(ts), formatter);</span>
	}


	public static Pointer timedelta_to_interval(Duration td){
<span class="nc" id="L63">		int years = 0;</span>
<span class="nc" id="L64">		int month = 0;</span>
<span class="nc" id="L65">		int weeks = 0;</span>
<span class="nc" id="L66">		int days = (int)td.toDays();</span>
<span class="nc" id="L67">		int hours = (int)td.toHours();</span>
<span class="nc" id="L68">		int minutes = (int)td.toMinutes();</span>
<span class="nc" id="L69">		double seconds = (double)td.toSeconds();</span>
<span class="nc" id="L70">		return functions.pg_interval_make(years,month,weeks,days,hours,minutes,seconds);</span>
	}

	public static Duration interval_to_timedelta(Pointer p){
<span class="fc" id="L74">		String res= functions.pg_interval_out(p);</span>
<span class="fc" id="L75">		System.out.println(res);</span>
<span class="fc" id="L76">		Pattern pattern = Pattern.compile(&quot;(\\d+)\\s+days(?:\\s+(\\d{2}):(\\d{2}):(\\d{2}))?&quot;);</span>
<span class="fc" id="L77">		Matcher matcher = pattern.matcher(res);</span>

<span class="pc bpc" id="L79" title="1 of 2 branches missed.">		if (matcher.matches()) {</span>
			// Extract days from the string
<span class="fc" id="L81">			int days = Integer.parseInt(matcher.group(1));</span>

			// Initialize hours, minutes, and seconds to zero
<span class="fc" id="L84">			int hours = 0;</span>
<span class="fc" id="L85">			int minutes = 0;</span>
<span class="fc" id="L86">			int seconds = 0;</span>

			// If the time component is present, extract hours, minutes, and seconds
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">			if (matcher.group(2) != null) {</span>
<span class="nc" id="L90">				hours = Integer.parseInt(matcher.group(2));</span>
<span class="nc" id="L91">				minutes = Integer.parseInt(matcher.group(3));</span>
<span class="nc" id="L92">				seconds = Integer.parseInt(matcher.group(4));</span>
			}

			// Calculate the total duration in seconds
<span class="fc" id="L96">			long totalSeconds = days * 86400L + hours * 3600L + minutes * 60L + seconds;</span>

<span class="fc" id="L98">			System.out.println(Duration.ofSeconds(totalSeconds));</span>
			// Create and return the Duration object
<span class="fc" id="L100">			return Duration.ofSeconds(totalSeconds);</span>
		} else {
<span class="nc" id="L102">			throw new IllegalArgumentException(&quot;Invalid interval format&quot;);</span>
		}
	}

	public static Pointer intrange_to_intspan(Range&lt;Integer&gt; intrange) throws SQLException {
<span class="nc bnc" id="L107" title="All 2 branches missed.">		boolean lower_inc = intrange.lowerBoundType() == BoundType.CLOSED;</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">		boolean upper_inc = intrange.upperBoundType() == BoundType.CLOSED;</span>
<span class="nc" id="L109">		return functions.intspan_make(intrange.lowerEndpoint(),intrange.upperEndpoint(),lower_inc, upper_inc);</span>
	}

	public static Range intspan_to_intrange(Pointer span){
<span class="nc bnc" id="L113" title="All 2 branches missed.">		BoundType lower_inc = functions.span_lower_inc(span) ? BoundType.CLOSED : BoundType.OPEN;</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">		BoundType upper_inc = functions.span_upper_inc(span) ? BoundType.CLOSED : BoundType.OPEN;</span>
<span class="nc" id="L115">		return Range.range(functions.intspan_lower(span), lower_inc, functions.intspan_upper(span), upper_inc);</span>
	}

	public static Pointer floatrange_to_floatspan(Range&lt;Float&gt; floatrange){
<span class="nc bnc" id="L119" title="All 2 branches missed.">		boolean lower_inc = floatrange.lowerBoundType() == BoundType.CLOSED;</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">		boolean upper_inc = floatrange.upperBoundType() == BoundType.CLOSED;</span>
<span class="nc" id="L121">		return functions.floatspan_make(floatrange.lowerEndpoint(),floatrange.upperEndpoint(),lower_inc, upper_inc);</span>
	}

	public static Range floatspan_to_floatrange(Pointer span){
<span class="nc bnc" id="L125" title="All 2 branches missed.">		BoundType lower_inc = functions.span_lower_inc(span) ? BoundType.CLOSED : BoundType.OPEN;</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">		BoundType upper_inc = functions.span_upper_inc(span) ? BoundType.CLOSED : BoundType.OPEN;</span>
<span class="nc" id="L127">		return Range.range(functions.floatspan_lower(span), lower_inc, functions.floatspan_upper(span), upper_inc);</span>
	}



//	public static TInstant asTInstant(Temporal temporal) {
//			return (TInstant) temporal;
//		}
//
//	public static TSequence asTSequence(Temporal temporal) {
//			return (TSequence) temporal;
//		}
//
//	public static TSequenceSet asTSequenceSet(Temporal temporal) {
//			return (TSequenceSet) temporal;
//		}


	public static Pointer geo_to_gserialized(Geometry geom, boolean geodetic){
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">		if (geodetic){</span>
<span class="nc" id="L147">			return geography_to_gserialized(geom);</span>
		}
		else{
<span class="fc" id="L150">			return geometry_to_gserialized(geom);</span>
		}
	}


	public static Pointer geometry_to_gserialized(Geometry geom){
<span class="fc" id="L156">		WKTWriter wktWriter = new WKTWriter();</span>
<span class="fc" id="L157">		String text = wktWriter.write(geom);</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">		if (geom.getSRID() &gt; 0){</span>
<span class="fc" id="L159">			text = &quot;SRID=&quot;+geom.getSRID()+&quot;;&quot;+text;</span>
		}
<span class="fc" id="L161">		Pointer ptr = functions.pgis_geometry_in(text,-1);</span>
<span class="fc" id="L162">		return ptr;</span>
	}


	public static Pointer geography_to_gserialized(Geometry geom){
<span class="fc" id="L167">		WKTWriter wktWriter = new WKTWriter();</span>
<span class="fc" id="L168">		String text = wktWriter.write(geom);</span>
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">		if (geom.getSRID() &gt; 0){</span>
<span class="fc" id="L170">			text = &quot;SRID=&quot;+geom.getSRID()+&quot;;&quot;+text;</span>
		}
<span class="fc" id="L172">		Pointer ptr = functions.pgis_geography_in(text,-1);</span>
<span class="fc" id="L173">		return ptr;</span>
	}

	public static Point gserialized_to_shapely_point(Pointer geom, int precision) throws ParseException, ParseException {
<span class="fc" id="L177">        Geometry geometry = gserialized_to_shapely_geometry(geom, precision);</span>
<span class="fc" id="L178">		return (Point) geometry;</span>
	}

	public static Geometry gserialized_to_shapely_geometry(Pointer geom, int precision) throws ParseException, ParseException {
<span class="fc" id="L182">		String text = functions.geo_as_text(geom,precision);</span>
<span class="fc" id="L183">		WKTReader wktReader = new WKTReader();</span>
<span class="fc" id="L184">		Geometry geometry = wktReader.read(text);</span>
<span class="fc" id="L185">		int srid = functions.geo_get_srid(geom);</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">		if (srid &gt; 0){</span>
<span class="fc" id="L187">			geometry.setSRID(srid);</span>
		}
<span class="fc" id="L189">		return geometry;</span>
	}

	public static String hexWKBToWKB(String hexWKB) {
<span class="nc bnc" id="L193" title="All 2 branches missed.">		if (hexWKB.length() % 2 != 0) {</span>
<span class="nc" id="L194">			System.err.println(&quot;Invalid HexWKB format.&quot;);</span>
<span class="nc" id="L195">			return null;</span>
		}

<span class="nc" id="L198">		StringBuilder wkbStringBuilder = new StringBuilder();</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">		for (int i = 0; i &lt; hexWKB.length(); i += 2) {</span>
<span class="nc" id="L200">			String hexPair = hexWKB.substring(i, i + 2);</span>
<span class="nc" id="L201">			int hexValue = Integer.parseInt(hexPair, 16);</span>
<span class="nc" id="L202">			wkbStringBuilder.append((char) hexValue);</span>
		}

<span class="nc" id="L205">		return wkbStringBuilder.toString();</span>
	}


	public static LocalDateTime string_to_LocalDateTime(String value){
<span class="nc" id="L210">		DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span>
<span class="nc" id="L211">        return LocalDateTime.parse(value, formatter);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>