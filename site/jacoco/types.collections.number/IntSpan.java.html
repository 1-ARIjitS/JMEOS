<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IntSpan.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jmeos</a> &gt; <a href="index.source.html" class="el_package">types.collections.number</a> &gt; <span class="el_source">IntSpan.java</span></div><h1>IntSpan.java</h1><pre class="source lang-java linenums">package types.collections.number;
import types.collections.base.Base;
import types.collections.base.Span;
import jnr.ffi.Pointer;
import functions.functions;

/**
 * Class for representing sets of contiguous integer values between a lower and
 *     an upper bound. The bounds may be inclusive or not.
 * &lt;p&gt;
 *     ``IntSpan`` objects can be created with a single argument of type string
 *     as in MobilityDB.
 * &lt;p&gt;
 *         &gt;&gt;&gt; IntSpan('(2, 5]')
 * &lt;p&gt;
 *     Another possibility is to provide the ``lower`` and ``upper`` named parameters (of type str or int), and
 *     optionally indicate whether the bounds are inclusive or exclusive (by default, the lower bound is inclusive and the
 *     upper is exclusive):
 * &lt;p&gt;
 *         &gt;&gt;&gt; IntSpan(lower=2, upper=5)
 *         &gt;&gt;&gt; IntSpan(lower=2, upper=5, lower_inc=False, upper_inc=True)
 *         &gt;&gt;&gt; IntSpan(lower='2', upper='5', upper_inc=True)
 *
 * @author ARIJIT SAMAL
 */
public class IntSpan extends Span&lt;Integer&gt; implements Number{
    private final Pointer _inner;

    /** ------------------------- Constructor ---------------------------------------- */

    public IntSpan(Pointer inner){
<span class="fc" id="L32">        super(inner);</span>
<span class="fc" id="L33">        _inner = inner;</span>
<span class="fc" id="L34">    }</span>

    public IntSpan(String str){
<span class="fc" id="L37">        super(str);</span>
<span class="fc" id="L38">        _inner = functions.intspan_in(str);</span>
<span class="fc" id="L39">    }</span>

    public IntSpan(int lower, int upper, boolean lower_inc, boolean upper_inc){
<span class="fc" id="L42">        super(lower,upper,lower_inc,upper_inc);</span>
<span class="fc" id="L43">        _inner = functions.intspan_make(lower,upper,lower_inc,upper_inc);</span>
<span class="fc" id="L44">    }</span>

    public IntSpan(int lower, String upper, boolean lower_inc, boolean upper_inc){
<span class="fc" id="L47">        super(lower,upper,lower_inc,upper_inc);</span>
<span class="fc" id="L48">        int new_upper = Integer.parseInt(upper);</span>
<span class="fc" id="L49">        _inner = functions.intspan_make(lower,new_upper,lower_inc,upper_inc);</span>
<span class="fc" id="L50">    }</span>

    public IntSpan(String lower, String upper, boolean lower_inc, boolean upper_inc){
<span class="fc" id="L53">        super(lower,upper,lower_inc,upper_inc);</span>
<span class="fc" id="L54">        int new_upper = Integer.parseInt(upper);</span>
<span class="fc" id="L55">        int new_lower = Integer.parseInt(lower);</span>
<span class="fc" id="L56">        _inner = functions.intspan_make(new_lower,new_upper,lower_inc,upper_inc);</span>
<span class="fc" id="L57">    }</span>

    public IntSpan(String lower, int upper, boolean lower_inc, boolean upper_inc){
<span class="nc" id="L60">        super(lower,upper,lower_inc,upper_inc);</span>
<span class="nc" id="L61">        int new_lower = Integer.parseInt(lower);</span>
<span class="nc" id="L62">        _inner = functions.intspan_make(new_lower,upper,lower_inc,upper_inc);</span>
<span class="nc" id="L63">    }</span>

    public IntSpan(int lower, int upper){
<span class="nc" id="L66">        super(lower,upper,true,false);</span>
<span class="nc" id="L67">        _inner = functions.intspan_make(lower,upper,true,false);</span>
<span class="nc" id="L68">    }</span>

    @Override
    public Pointer createStringInner(String str){
<span class="fc" id="L72">        return functions.intspan_in(str);</span>
    }

    @Override
    public Pointer createInner(Pointer inner){
<span class="fc" id="L77">        return inner;</span>
    }

    @Override
    public Pointer createIntInt(java.lang.Number lower, java.lang.Number upper, boolean lower_inc, boolean upper_inc){
<span class="fc" id="L82">        return functions.intspan_make(lower.intValue(),upper.intValue(),lower_inc,upper_inc);</span>
    }
    @Override
    public Pointer createIntStr(java.lang.Number lower, String upper, boolean lower_inc, boolean upper_inc){
<span class="fc" id="L86">        int new_upper = Integer.parseInt(upper);</span>
<span class="fc" id="L87">        return functions.intspan_make(lower.intValue(),new_upper,lower_inc,upper_inc);</span>
    }
    @Override
    public Pointer createStrStr(String lower, String upper, boolean lower_inc, boolean upper_inc){
<span class="fc" id="L91">        int new_upper = Integer.parseInt(upper);</span>
<span class="fc" id="L92">        int new_lower = Integer.parseInt(lower);</span>
<span class="fc" id="L93">        return functions.intspan_make(new_lower,new_upper,lower_inc,upper_inc);</span>
    }
    @Override
    public Pointer createStrInt(String lower, java.lang.Number upper, boolean lower_inc, boolean upper_inc){
<span class="nc" id="L97">        int new_lower = Integer.parseInt(lower);</span>
<span class="nc" id="L98">        return functions.intspan_make(new_lower,upper.intValue(),lower_inc,upper_inc);</span>
    }
    @Override
    public Pointer createIntIntNb(java.lang.Number lower, java.lang.Number upper){
<span class="nc" id="L102">        return functions.intspan_make(lower.intValue(),upper.intValue(),true,false);</span>
    }

    /**
     * Return a copy of &quot;this&quot;.
     * &lt;p&gt;
     * MEOS Functions:
     * &lt;li&gt;span_copy&lt;/li&gt;
     *
     * @return a new IntSpan instance
     */
    public IntSpan copy(){
<span class="fc" id="L114">        return new IntSpan(functions.span_copy(this._inner));</span>
    }
    /*
    public IntSpan from_wkb(Byte b){
        return new IntSpan(functions.span_from_wkb(b));
    }

     */

    /**
     * Returns a tstzspan from its WKB representation in hex-encoded ASCII.
     *
     *  &lt;p&gt;
     *
     *         MEOS Functions:
     *             &lt;li&gt;span_from_hexwkb&lt;/li&gt;
     *
     * @param str WKB representation in hex-encoded ASCII
     * @return
     */
    public IntSpan from_hexwkb(String str){
<span class="nc" id="L135">        return new IntSpan(functions.span_from_hexwkb(str));</span>
    }

    /* ------------------------- Output ---------------------------------------- */

    /**
     * Return the string representation of the content of &quot;this&quot;.
     *
     *  &lt;p&gt;
     *         MEOS Functions:
     *             &lt;li&gt;intspan_out&lt;/li&gt;
     *
     *
     * @return A new {@link String} instance
     */
    public String toString(){
<span class="fc" id="L151">        return functions.intspan_out(this._inner);</span>
    }



    /* ------------------------- Conversions ----------------------------------- */


    /**
     * Returns a SpanSet that contains a Span for each element in &quot;this&quot;.
     *
     *  &lt;p&gt;
     *
     *         MEOS Functions:
     *             &lt;li&gt;span_to_spanset&lt;/li&gt;
     *
     * @return A new {@link IntSpanSet} instance
     */
    public IntSpanSet to_spanset(){
<span class="fc" id="L170">        return new IntSpanSet(functions.span_to_spanset(this._inner));</span>
    }


    /**
     * Converts &quot;this&quot; to a {@link FloatSpan} instance.
     *
     * &lt;p&gt;
     *
     *         MEOS Functions:
     *             &lt;li&gt;intspan_floatspan&lt;/li&gt;
     *
     * @return A new :class:`FloatSpan` instance
     */

    public FloatSpan tofloatspan(){
<span class="nc" id="L186">        return new FloatSpan(functions.intspan_to_floatspan(this._inner));</span>
    }




    /** ------------------------- Accessors ------------------------------------- */

    @Override
    public Pointer get_inner(){
<span class="fc" id="L196">        return _inner;</span>
    }


    /**
     * Returns the lower bound of &quot;this&quot;.
     *
     *  &lt;p&gt;
     *
     *         MEOS Functions:
     *             &lt;li&gt;period_lower&lt;/li&gt;
     *
     * @return The lower bound of the span as a {@link Integer}
     */
    public Integer lower(){
<span class="fc" id="L211">        return functions.intspan_lower(this._inner);</span>
    }



    /**
     * Returns the upper bound of &quot;this&quot;.
     *
     *  &lt;p&gt;
     *
     *         MEOS Functions:
     *             &lt;li&gt;period_upper&lt;/li&gt;
     *
     * @return The lower bound of the span as a {@link Integer}
     */
    public Integer upper(){
<span class="fc" id="L227">        return functions.intspan_upper(this._inner);</span>
    }


    /**
     * Returns the width of &quot;this&quot;.
     *
     *  &lt;p&gt;
     *
     *         MEOS Functions:
     *             &lt;li&gt;span_width&lt;/li&gt;
     *
     * @return Returns a &quot;float&quot; representing the width of the span
     */
    public float width(){
<span class="fc" id="L242">        return (float) functions.intspan_width(this._inner);</span>
    }

    /* ------------------------- Transformations ------------------------------- */


    /**
     * Return a new &quot;IntSpanSet&quot; with the lower and upper bounds shifted by
     *         &quot;delta&quot;.
     *
     *  &lt;p&gt;
     *         MEOS Functions:
     *             &lt;li&gt;floatspanset_shift_scale&lt;/li&gt;
     *
     *
     * @param delta The value to shift by
     * @return A new {@link IntSpanSet} instance
     */

    public IntSpan shift(int delta){
<span class="nc" id="L262">        return this.shift_scale(delta,0);</span>
    }


    /**
     * Return a new &quot;IntSpanSet&quot; with the lower and upper bounds scaled so
     *         that the width is &quot;width&quot;.
     *
     *  &lt;p&gt;
     *         MEOS Functions:
     *             &lt;li&gt;floatspanset_shift_scale&lt;/li&gt;
     *
     * @param width The new width
     * @return a new {@link IntSpanSet} instance
     */

    public IntSpan scale(int width){
<span class="nc" id="L279">        return this.shift_scale(0,width);</span>
    }



    /**
     * Return a new &quot;IntSpanSet&quot; with the lower and upper bounds shifted by
     *         &quot;delta&quot; and scaled so that the width is &quot;width&quot;.
     *
     *  &lt;p&gt;
     *         MEOS Functions:
     *             &lt;li&gt;floatspanset_shift_scale&lt;/li&gt;
     *
     * @param delta The value to shift by
     * @param width v
     * @return a new {@link IntSpanSet} instance
     */

    public IntSpan shift_scale(int delta, int width){
<span class="nc bnc" id="L298" title="All 4 branches missed.">        return new IntSpan(functions.intspanset_shift_scale(this._inner,delta,width,delta != 0,width!=0));</span>
    }



    /* ------------------------- Topological Operations -------------------------------- */

    /**
     * Returns whether &quot;this&quot; is adjacent to &quot;other&quot;. That is, they share
     *         a bound but only one of them contains it.
     *
     *  &lt;p&gt;
     *
     *         MEOS Functions:
     *             &lt;li&gt;adjacent_span_span&lt;/li&gt;
     *             &lt;li&gt;adjacent_span_spanset&lt;/li&gt;
     *             &lt;li&gt;adjacent_intspan_int&lt;/li&gt;
     *
     * @param other object to compare with
     * @return True if adjacent, False otherwise
     * @throws Exception
     */
    public boolean is_adjacent(Object other) throws Exception {
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">        if (other instanceof Integer){</span>
<span class="fc" id="L322">            return functions.adjacent_span_int(this._inner, (int) other);</span>
        }
        else {
<span class="nc" id="L325">            return super.is_adjacent((Base) other);</span>
        }
    }


    /**
     * Returns whether &quot;this&quot; contains &quot;content&quot;.
     *
     * &lt;p&gt;
     *
     *         MEOS Functions:
     *             &lt;li&gt;contains_set_set&lt;/li&gt;
     *             &lt;li&gt;contains_intspan_int&lt;/li&gt;
     *
     * @param other object to compare with
     * @return True if contains, False otherwise
     * @throws Exception
     */
    public boolean contains(Object other) throws Exception {
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">        if (other instanceof Integer){</span>
<span class="fc" id="L345">            return functions.contains_span_int(this._inner, (int) other);</span>
        }
        else {
<span class="nc" id="L348">            return super.contains((Base) other);</span>
        }
    }


    /**
     * Returns whether &quot;this&quot; and the bounding period of &quot;other is the
     *         same.
     *
     *  &lt;p&gt;
     *
     *         MEOS Functions:
     *             &lt;li&gt;same_period_temporal&lt;/li&gt;
     *
     * @param other object to compare with
     * @return True if equal, False otherwise
     * @throws Exception
     */
    public boolean is_same(Object other) throws Exception {
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">        if (other instanceof Integer){</span>
<span class="fc" id="L368">            return functions.span_eq(this._inner, functions.int_to_span((int)other));</span>
        }
        else {
<span class="nc" id="L371">            return super.is_same((Base) other);</span>
        }
    }



    /* ------------------------- Position Operations --------------------------- */


    /**
     * Returns whether &quot;this&quot; is strictly before &quot;other&quot;. That is,
     *         &quot;this&quot; ends before &quot;other&quot; starts.
     *
     *  &lt;p&gt;
     *
     *         MEOS Functions:
     *             left_span_span
     *             left_span_spanset
     *             left_intspan_int
     *
     * @param other object to compare with
     * @return True if before, False otherwise
     * @throws Exception
     */
    public boolean is_left(Object other) throws Exception {
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">        if (other instanceof Integer){</span>
<span class="fc" id="L397">            return functions.left_span_int(this._inner, (int) other);</span>
        }
        else {
<span class="nc" id="L400">            return super.is_left((Base) other);</span>
        }
    }


    /**
     * Returns whether &quot;this&quot; is before &quot;other&quot; allowing overlap. That is,
     *         &quot;this ends before &quot;other&quot; ends (or at the same value).
     *
     *  &lt;p&gt;
     *
     *         MEOS Functions:
     *             &lt;li&gt;overleft_span_span&lt;/li&gt;
     *             &lt;li&gt;overleft_span_spanset&lt;/li&gt;
     *             &lt;li&gt;overleft_intspan_int&lt;/li&gt;
     *
     * @param other object to compare with
     * @return True if before, False otherwise
     * @throws Exception
     */
    public boolean is_over_or_left(Object other) throws Exception {
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">        if (other instanceof Integer){</span>
<span class="fc" id="L422">            return functions.overleft_span_int(this._inner, (int) other);</span>
        }
        else {
<span class="nc" id="L425">            return super.is_over_or_left((Base) other);</span>
        }
    }

    /**
     * Returns whether &quot;this&quot; is strictly after &quot;other&quot;. That is, &quot;this&quot;
     *         starts after &quot;other&quot; ends.
     *
     *   &lt;p&gt;
     *
     *         MEOS Functions:
     *             &lt;li&gt;right_span_span&lt;/li&gt;
     *             &lt;li&gt;right_span_spanset&lt;/li&gt;
     *             &lt;li&gt;right_intspan_int&lt;/li&gt;
     *
     * @param other object to compare with
     * @return True if after, False otherwise
     * @throws Exception
     */
    public boolean is_right(Object other) throws Exception {
<span class="pc bpc" id="L445" title="1 of 2 branches missed.">        if (other instanceof Integer){</span>
<span class="fc" id="L446">            return functions.right_span_int(this._inner, (int) other);</span>
        }
        else {
<span class="nc" id="L449">            return super.is_right((Base) other);</span>
        }
    }


    /**
     * Returns whether &quot;this&quot; is after &quot;other&quot; allowing overlap. That is,
     *         &quot;this&quot; starts after &quot;other&quot; starts (or at the same value).
     *
     *  &lt;p&gt;
     *
     *         MEOS Functions:
     *             &lt;li&gt;overright_span_span&lt;/li&gt;
     *             &lt;li&gt;overright_span_spanset&lt;/li&gt;
     *             &lt;li&gt;overright_intspan_int&lt;/li&gt;
     *
     * @param other object to compare with
     * @return True if overlapping or after, False otherwise
     * @throws Exception
     */
    public boolean is_over_or_right(Object other) throws Exception {
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">        if (other instanceof Integer){</span>
<span class="fc" id="L471">            return functions.overright_span_int(this._inner, (int) other);</span>
        }
        else {
<span class="nc" id="L474">            return super.is_over_or_right((Base) other);</span>
        }
    }



    /* ------------------------- Distance Operations --------------------------- */


    /**
     * Returns the distance between &quot;this&quot; and &quot;other&quot;.
     *
     *  &lt;p&gt;
     *
     *         MEOS Functions:
     *             &lt;li&gt;distance_span_span&lt;/li&gt;
     *             &lt;li&gt;distance_span_spanset&lt;/li&gt;
     *             &lt;li&gt;distance_intspan_int&lt;/li&gt;
     *
     * @param other object to compare with
     * @return A float value
     * @throws Exception
     */
    public Float distance(Object other) throws Exception {
<span class="nc bnc" id="L498" title="All 2 branches missed.">        if (other instanceof Integer){</span>
<span class="nc" id="L499">            return (float) functions.distance_span_int(this._inner, (int) other);</span>
        }
<span class="nc" id="L501">        return 0f;</span>
    }


    /* ------------------------- Set Operations -------------------------------- */


    public IntSpan intersection(Object other) throws Exception {
<span class="nc" id="L509">        Pointer result = null;</span>
<span class="nc bnc" id="L510" title="All 4 branches missed.">        if ((other instanceof Integer) || (other instanceof Float)){</span>
<span class="nc" id="L511">            result= functions.intersection_span_int(this._inner, (int) other);</span>
        }
<span class="nc bnc" id="L513" title="All 2 branches missed.">        else if (other instanceof IntSpan){</span>
<span class="nc" id="L514">            result= functions.intersection_span_span(this._inner, ((IntSpan) other)._inner);</span>
        }
<span class="nc bnc" id="L516" title="All 2 branches missed.">        else if (other instanceof IntSpanSet){</span>
<span class="nc" id="L517">            result= functions.intersection_spanset_span(this._inner, ((IntSpanSet) other).get_inner());</span>
        }
<span class="nc bnc" id="L519" title="All 2 branches missed.">        else if ((other instanceof IntSet)){</span>
<span class="nc" id="L520">            result= functions.intersection_set_set(this._inner, ((IntSet) other).get_inner());</span>
        }
        else {
<span class="nc" id="L523">            throw new Exception(&quot;Operation not supported with &quot; + other + &quot; type&quot;);</span>
        }
<span class="nc" id="L525">        return new IntSpan(result);</span>
    }


    /**
     * Returns the difference of &quot;this&quot; and &quot;other&quot;.
     *
     *  &lt;p&gt;
     *         MEOS Functions:
     *             &lt;li&gt;minus_span_span&lt;/li&gt;
     *             &lt;li&gt;minus_spanset_span&lt;/li&gt;
     *             &lt;li&gt;minus_intspan_int&lt;/li&gt;
     *
     * @param other object to diff with
     * @return A {@link IntSpanSet} instance.
     */
    public IntSpanSet minus(Object other){
<span class="fc" id="L542">        Pointer result = null;</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">        if (other instanceof Integer){</span>
<span class="fc" id="L544">            result = functions.minus_span_int(this._inner,(int)other);</span>
        }
<span class="fc bfc" id="L546" title="All 2 branches covered.">        else if (other instanceof IntSpan) {</span>
<span class="fc" id="L547">            result = functions.minus_span_span(this._inner,((IntSpan) other).get_inner());</span>
        }
<span class="pc bpc" id="L549" title="1 of 2 branches missed.">        else if (other instanceof IntSpanSet) {</span>
<span class="fc" id="L550">            result = functions.minus_spanset_span(((IntSpanSet) other).get_inner(), this._inner);</span>
        }
<span class="fc" id="L552">        return new IntSpanSet(result);</span>
    }


    /**
     * Returns the union of &quot;this&quot; and &quot;other&quot;.
     *
     *  &lt;p&gt;
     *
     *         MEOS Functions:
     *             &lt;li&gt;union_spanset_span&lt;/li&gt;
     *             &lt;li&gt;union_span_span&lt;/li&gt;
     *             &lt;li&gt;union_intspan_int&lt;/li&gt;
     *
     * @param other object to merge with
     * @return A {@link IntSpanSet} instance.
     */
    public IntSpanSet union(Object other) throws Exception {
<span class="fc" id="L570">        Pointer result = null;</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">        if (other instanceof Integer){</span>
<span class="fc" id="L572">            result = functions.union_span_int(this._inner,(int)other);</span>
        }
<span class="fc bfc" id="L574" title="All 2 branches covered.">        else if (other instanceof IntSpan) {</span>
<span class="fc" id="L575">            result = functions.union_span_span(this._inner,((IntSpan) other).get_inner());</span>
        }
<span class="pc bpc" id="L577" title="1 of 2 branches missed.">        else if (other instanceof IntSpanSet) {</span>
<span class="fc" id="L578">            result = functions.union_spanset_span(((IntSpanSet) other).get_inner(), this._inner);</span>
        }
        else {
<span class="nc" id="L581">            throw new Exception(&quot;Operation not supported with this type&quot;);</span>
        }
<span class="fc" id="L583">        return new IntSpanSet(result);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>